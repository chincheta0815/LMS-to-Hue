readp:squeezetiny/vorbis.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/vorbis.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/vorbis.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/vorbis.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/vorbis.c:#define LOCK_O_not_direct   if (!ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/vorbis.c:#define UNLOCK_O_not_direct if (!ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/vorbis.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/vorbis.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/vorbis.c:		ctx->output.track_start = ctx->outputbuf->writep;
readp:squeezetiny/vorbis.c:		write_buf = ctx->outputbuf->writep;
readp:squeezetiny/mad.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/mad.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/mad.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/mad.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/mad.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/mad.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/mad.c:			ctx->output.track_start = ctx->outputbuf->writep;
readp:squeezetiny/mad.c:				optr = (s16_t *)ctx->outputbuf->writep;
readp:squeezetiny/process.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/process.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/process.c:		u16_t *optr = (u16_t *)ctx->outputbuf->writep;
readp:squeezetiny/pcm.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/pcm.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/pcm.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/pcm.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/pcm.c:#define LOCK_O_not_direct   if (!ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/pcm.c:#define UNLOCK_O_not_direct if (!ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/pcm.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/pcm.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/pcm.c:		optr = ctx->outputbuf->writep;
readp:squeezetiny/pcm.c:		ctx->output.track_start = ctx->outputbuf->writep;
readp:squeezetiny/decode.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/decode.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/faad.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/faad.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/faad.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/faad.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/faad.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/faad.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/faad.c:			ctx->output.track_start = ctx->outputbuf->writep;
readp:squeezetiny/faad.c:			optr = (s16_t *)ctx->outputbuf->writep;
readp:squeezetiny/opus.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/opus.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/opus.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/opus.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/opus.c:#define LOCK_O_not_direct   if (!ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/opus.c:#define UNLOCK_O_not_direct if (!ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/opus.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/opus.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/opus.c:		ctx->output.track_start = ctx->outputbuf->writep;
readp:squeezetiny/opus.c:		write_buf = ctx->outputbuf->writep;
readp:squeezetiny/output_huebridge.c:#define LOCK   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/output_huebridge.c:#define UNLOCK mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/output_huebridge.c:        obuf = ctx->outputbuf->readp;
readp:squeezetiny/alac.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/alac.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/alac.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/alac.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/alac.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/alac.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/alac.c:			ctx->output.track_start = ctx->outputbuf->writep;
readp:squeezetiny/alac.c:			optr = (s16_t *)ctx->outputbuf->writep;
readp:squeezetiny/flac.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/flac.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/flac.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/flac.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/flac.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/flac.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/flac.c:		ctx->output.track_start = ctx->outputbuf->writep;
readp:squeezetiny/flac.c:			optr = (s16_t *)ctx->outputbuf->writep;
readp:squeezetiny/slimproto.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/slimproto.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/slimproto.c:			ctx->status.output_size = ctx->outputbuf->size;
readp:squeezetiny/output.c:#define LOCK   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/output.c:#define UNLOCK mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/output.c:			if (ctx->output.track_start == ctx->outputbuf->readp) {
readp:squeezetiny/output.c:			} else if (ctx->output.track_start > ctx->outputbuf->readp) {
readp:squeezetiny/output.c:				cont_frames = min(cont_frames, (ctx->output.track_start - ctx->outputbuf->readp) / BYTES_PER_FRAME);
readp:squeezetiny/output.c:				if (ctx->output.fade_start == ctx->outputbuf->readp) {
readp:squeezetiny/output.c:				} else if (ctx->output.fade_start > ctx->outputbuf->readp) {
readp:squeezetiny/output.c:					cont_frames = min(cont_frames, (ctx->output.fade_start - ctx->outputbuf->readp) / BYTES_PER_FRAME);
readp:squeezetiny/output.c:				frames_t cur_f = ctx->outputbuf->readp >= ctx->output.fade_start ? (ctx->outputbuf->readp - ctx->output.fade_start) / BYTES_PER_FRAME :
readp:squeezetiny/output.c:					(ctx->outputbuf->readp + ctx->outputbuf->size - ctx->output.fade_start) / BYTES_PER_FRAME;
readp:squeezetiny/output.c:					(ctx->output.fade_end + ctx->outputbuf->size - ctx->output.fade_start) / BYTES_PER_FRAME;
readp:squeezetiny/output.c:						ctx->output.fade_start = ctx->outputbuf->readp;
readp:squeezetiny/output.c:						ctx->output.fade_end = ctx->outputbuf->readp + dur_f * BYTES_PER_FRAME;
readp:squeezetiny/output.c:						if (ctx->output.fade_end >= ctx->outputbuf->wrap) {
readp:squeezetiny/output.c:							ctx->output.fade_end -= ctx->outputbuf->size;
readp:squeezetiny/output.c:					if (ctx->output.fade_end > ctx->outputbuf->readp) {
readp:squeezetiny/output.c:						cont_frames = min(cont_frames, (ctx->output.fade_end - ctx->outputbuf->readp) / BYTES_PER_FRAME);
readp:squeezetiny/output.c:		bytes = min(bytes, ctx->outputbuf->size - BYTES_PER_FRAME); // shorter than full buffer otherwise start and end align
readp:squeezetiny/output.c:		ctx->output.fade_start = ctx->outputbuf->writep;
readp:squeezetiny/output.c:		if (ctx->output.fade_end >= ctx->outputbuf->wrap) {
readp:squeezetiny/output.c:			ctx->output.fade_end -= ctx->outputbuf->size;
readp:squeezetiny/output.c:		ctx->output.fade_start = ctx->outputbuf->writep - bytes;
readp:squeezetiny/output.c:		if (ctx->output.fade_start < ctx->outputbuf->buf) {
readp:squeezetiny/output.c:			ctx->output.fade_start += ctx->outputbuf->size;
readp:squeezetiny/output.c:		ctx->output.fade_end = ctx->outputbuf->writep;
readp:squeezetiny/output.c:			bytes = min(bytes, (frames_t)(ctx->outputbuf->size * 0.9));  // max of 90% of outputbuf as we consume additional buffer during crossfade
readp:squeezetiny/output.c:			ctx->output.fade_start = ctx->outputbuf->writep - bytes;
readp:squeezetiny/output.c:			if (ctx->output.fade_start < ctx->outputbuf->buf) {
readp:squeezetiny/output.c:				ctx->output.fade_start += ctx->outputbuf->size;
readp:squeezetiny/output.c:			ctx->output.fade_end = ctx->outputbuf->writep;
readp:squeezetiny/output.c:		else if (ctx->outputbuf->size == OUTPUTBUF_SIZE && ctx->outputbuf->readp == ctx->outputbuf->buf) {
readp:squeezetiny/output.c:			touch_memory(ctx->outputbuf->buf, ctx->outputbuf->size);
readp:squeezetiny/output.c:	if (!ctx->outputbuf->buf) {
readp:squeezetiny/mpg.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/mpg.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/mpg.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/mpg.c:#define LOCK_O_not_direct   if (!ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/mpg.c:#define UNLOCK_O_not_direct if (!ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/mpg.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
readp:squeezetiny/mpg.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
readp:squeezetiny/mpg.c:		write_buf = ctx->outputbuf->writep;
readp:squeezetiny/mpg.c:			ctx->output.track_start = ctx->outputbuf->writep;
squeezetiny/vorbis.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
squeezetiny/vorbis.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
squeezetiny/vorbis.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/vorbis.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/vorbis.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
squeezetiny/vorbis.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/vorbis.c:#define LOCK_O_not_direct   if (!ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
squeezetiny/vorbis.c:#define UNLOCK_O_not_direct if (!ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/vorbis.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
squeezetiny/vorbis.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
squeezetiny/vorbis.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/vorbis.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/vorbis.c:	bytes = min(_buf_used(ctx->streambuf), _buf_cont_read(ctx->streambuf));
squeezetiny/vorbis.c:	memcpy(ptr, ctx->streambuf->readp, bytes);
squeezetiny/vorbis.c:	_buf_inc_readp(ctx->streambuf, bytes);
squeezetiny/vorbis.c:	struct vorbis *v = ctx->decode.handle;
squeezetiny/vorbis.c:		frames = min(_buf_space(ctx->outputbuf), _buf_cont_write(ctx->outputbuf)) / BYTES_PER_FRAME;
squeezetiny/vorbis.c:		frames = ctx->process.max_in_frames;
squeezetiny/vorbis.c:	if (!frames && ctx->stream.state <= DISCONNECT) {
squeezetiny/vorbis.c:	if (ctx->decode.new_stream) {
squeezetiny/vorbis.c:		ctx->output.current_sample_rate = decode_newstream(info->rate, ctx->output.supported_rates, ctx);
squeezetiny/vorbis.c:		ctx->output.track_start = ctx->outputbuf->writep;
squeezetiny/vorbis.c:		if (ctx->output.fade_mode) _checkfade(true, ctx);
squeezetiny/vorbis.c:		ctx->decode.new_stream = false;
squeezetiny/vorbis.c:			frames = ctx->process.max_in_frames;
squeezetiny/vorbis.c:		write_buf = ctx->outputbuf->writep;
squeezetiny/vorbis.c:		write_buf = ctx->process.inbuf;
squeezetiny/vorbis.c:			_buf_inc_writep(ctx->outputbuf, frames * BYTES_PER_FRAME);
squeezetiny/vorbis.c:			ctx->process.in_frames = frames;
squeezetiny/vorbis.c:		if (ctx->stream.state <= DISCONNECT) {
squeezetiny/vorbis.c:	struct vorbis *v = ctx->decode.handle;
squeezetiny/vorbis.c:		v = ctx->decode.handle = malloc(sizeof(struct vorbis));
squeezetiny/vorbis.c:	struct vorbis *v = ctx->decode.handle;
squeezetiny/vorbis.c:	ctx->decode.handle = NULL;
squeezetiny/mad.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
squeezetiny/mad.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
squeezetiny/mad.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/mad.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/mad.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
squeezetiny/mad.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/mad.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
squeezetiny/mad.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
squeezetiny/mad.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/mad.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/mad.c:	u8_t *ptr = ctx->streambuf->readp;
squeezetiny/mad.c:	u8_t *ptr = ctx->streambuf->readp;
squeezetiny/mad.c:	struct mad *m = ctx->decode.handle;
squeezetiny/mad.c:	struct mad *m = ctx->decode.handle;
squeezetiny/mad.c:	bytes = min(_buf_used(ctx->streambuf), _buf_cont_read(ctx->streambuf));
squeezetiny/mad.c:			_buf_inc_readp(ctx->streambuf, consume);
squeezetiny/mad.c:			if (!ctx->stream.meta_interval) {
squeezetiny/mad.c:	memcpy(m->readbuf + m->readbuf_len, ctx->streambuf->readp, bytes);
squeezetiny/mad.c:	_buf_inc_readp(ctx->streambuf, bytes);
squeezetiny/mad.c:	if (ctx->stream.state <= DISCONNECT && _buf_used(ctx->streambuf) == 0) {
squeezetiny/mad.c:		if (ctx->decode.new_stream) {
squeezetiny/mad.c:			ctx->output.current_sample_rate = decode_newstream(m->synth.pcm.samplerate, ctx->output.supported_rates, ctx);
squeezetiny/mad.c:			ctx->output.track_start = ctx->outputbuf->writep;
squeezetiny/mad.c:			if (ctx->output.fade_mode) _checkfade(true, ctx);
squeezetiny/mad.c:			ctx->decode.new_stream = false;
squeezetiny/mad.c:			max_frames = _buf_space(ctx->outputbuf) / BYTES_PER_FRAME;
squeezetiny/mad.c:			max_frames = ctx->process.max_in_frames - ctx->process.in_frames;
squeezetiny/mad.c:				f = min(frames, _buf_cont_write(ctx->outputbuf) / BYTES_PER_FRAME);
squeezetiny/mad.c:				optr = (s16_t *)ctx->outputbuf->writep;
squeezetiny/mad.c:				f = min(frames, ctx->process.max_in_frames - ctx->process.in_frames);
squeezetiny/mad.c:				optr = (s16_t *)((u8_t *) ctx->process.inbuf + ctx->process.in_frames * BYTES_PER_FRAME);
squeezetiny/mad.c:				_buf_inc_writep(ctx->outputbuf, f * BYTES_PER_FRAME);
squeezetiny/mad.c:				ctx->process.in_frames += f;
squeezetiny/mad.c:	struct mad *m = ctx->decode.handle;
squeezetiny/mad.c:		m = ctx->decode.handle = malloc(sizeof(struct mad));
squeezetiny/mad.c:	struct mad *m = ctx->decode.handle;
squeezetiny/mad.c:	ctx->decode.handle = NULL;
squeezetiny/process.c:#define LOCK_D   mutex_lock(ctx->decode.mutex);
squeezetiny/process.c:#define UNLOCK_D mutex_unlock(ctx->decode.mutex);
squeezetiny/process.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/process.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/process.c:	size_t frames = ctx->process.out_frames;
squeezetiny/process.c:	u16_t *iptr   = (u16_t *) ctx->process.outbuf;
squeezetiny/process.c:		frames_t f = min(_buf_space(ctx->outputbuf), _buf_cont_write(ctx->outputbuf)) / BYTES_PER_FRAME;
squeezetiny/process.c:		u16_t *optr = (u16_t *)ctx->outputbuf->writep;
squeezetiny/process.c:			_buf_inc_writep(ctx->outputbuf, f * BYTES_PER_FRAME);
squeezetiny/process.c:	ctx->process.in_frames = 0;
squeezetiny/process.c:	LOG_DEBUG("[%p]: processing track complete - frames in: %lu out: %lu", ctx, ctx->process.total_in, ctx->process.total_out);
squeezetiny/process.c:		ctx->process.in_frames = ctx->process.out_frames = 0;
squeezetiny/process.c:		ctx->process.total_in = ctx->process.total_out = 0;
squeezetiny/process.c:		max_in_frames = ctx->codec->min_space / BYTES_PER_FRAME ;
squeezetiny/process.c:		if (ctx->process.out_sample_rate % ctx->process.in_sample_rate == 0) {
squeezetiny/process.c:			max_out_frames = max_in_frames * (ctx->process.out_sample_rate / ctx->process.in_sample_rate);
squeezetiny/process.c:			max_out_frames = (int)(1.1 * (float)max_in_frames * (float)ctx->process.out_sample_rate / (float)ctx->process.in_sample_rate);
squeezetiny/process.c:		if (ctx->process.max_in_frames != max_in_frames) {
squeezetiny/process.c:			if (ctx->process.inbuf) free(ctx->process.inbuf);
squeezetiny/process.c:			ctx->process.inbuf = malloc(max_in_frames * BYTES_PER_FRAME);
squeezetiny/process.c:			ctx->process.max_in_frames = max_in_frames;
squeezetiny/process.c:		if (ctx->process.max_out_frames != max_out_frames) {
squeezetiny/process.c:			if (ctx->process.outbuf) free(ctx->process.outbuf);
squeezetiny/process.c:			ctx->process.outbuf = malloc(max_out_frames * BYTES_PER_FRAME);
squeezetiny/process.c:			ctx->process.max_out_frames = max_out_frames;
squeezetiny/process.c:		if (!ctx->process.inbuf || !ctx->process.outbuf) {
squeezetiny/process.c:		return ctx->process.out_sample_rate;
squeezetiny/process.c:	ctx->process.in_frames = 0;
squeezetiny/process.c:	memset(&ctx->process, 0, sizeof(ctx->process));
squeezetiny/process.c:		ctx->decode.process = true;
squeezetiny/process.c:	ctx->decode.process = false;
squeezetiny/process.c:	if (ctx->process.inbuf) free(ctx->process.inbuf);
squeezetiny/process.c:	if (ctx->process.outbuf) free(ctx->process.outbuf);
squeezetiny/pcm.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
squeezetiny/pcm.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
squeezetiny/pcm.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/pcm.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/pcm.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
squeezetiny/pcm.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/pcm.c:#define LOCK_O_not_direct   if (!ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
squeezetiny/pcm.c:#define UNLOCK_O_not_direct if (!ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/pcm.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
squeezetiny/pcm.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
squeezetiny/pcm.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/pcm.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/pcm.c:	u8_t *ptr = ctx->streambuf->readp;
squeezetiny/pcm.c:	struct pcm *p = ctx->decode.handle;
squeezetiny/pcm.c:		while (ctx->streambuf->readp - ptr < MIN_READ - 22) {
squeezetiny/pcm.c:				bytes = ptr - ctx->streambuf->readp + offset + (8+8);
squeezetiny/pcm.c:	} else if (p->big_endian && !(*(u64_t*) ptr) && (strstr(ctx->server_version, "7.7") || strstr(ctx->server_version, "7.8"))) {
squeezetiny/pcm.c:	struct pcm *p = ctx->decode.handle;
squeezetiny/pcm.c:	if (ctx->stream.state <= DISCONNECT && _buf_used(ctx->streambuf) < p->bytes_per_frame) {
squeezetiny/pcm.c:		out = min(_buf_space(ctx->outputbuf), _buf_cont_write(ctx->outputbuf)) / BYTES_PER_FRAME;
squeezetiny/pcm.c:		optr = ctx->outputbuf->writep;
squeezetiny/pcm.c:		out = ctx->process.max_in_frames;
squeezetiny/pcm.c:		optr = ctx->process.inbuf;
squeezetiny/pcm.c:	if (ctx->decode.new_stream) {
squeezetiny/pcm.c:		_buf_inc_readp(ctx->streambuf, bytes);
squeezetiny/pcm.c:		ctx->output.current_sample_rate = decode_newstream(p->sample_rate, ctx->output.supported_rates, ctx);
squeezetiny/pcm.c:		ctx->output.track_start = ctx->outputbuf->writep;
squeezetiny/pcm.c:		if (ctx->output.fade_mode) _checkfade(true, ctx);
squeezetiny/pcm.c:		ctx->decode.new_stream = false;
squeezetiny/pcm.c:			out = ctx->process.max_in_frames;
squeezetiny/pcm.c:	bytes = min(_buf_used(ctx->streambuf), _buf_cont_read(ctx->streambuf));
squeezetiny/pcm.c:	iptr = (u8_t *)ctx->streambuf->readp;
squeezetiny/pcm.c:	if (in == 0 && bytes > 0 && _buf_used(ctx->streambuf) >= p->bytes_per_frame) {
squeezetiny/pcm.c:		memcpy(buf + bytes, ctx->streambuf->buf, p->bytes_per_frame - bytes);
squeezetiny/pcm.c:	_buf_inc_readp(ctx->streambuf, frames * p->bytes_per_frame);
squeezetiny/pcm.c:		_buf_inc_writep(ctx->outputbuf, frames * BYTES_PER_FRAME);
squeezetiny/pcm.c:		ctx->process.in_frames = frames;
squeezetiny/pcm.c:	struct pcm *p = ctx->decode.handle;
squeezetiny/pcm.c:	if (!p)	p = ctx->decode.handle = malloc(sizeof(struct pcm));
squeezetiny/pcm.c:	if (ctx->decode.handle) free(ctx->decode.handle);
squeezetiny/pcm.c:	ctx->decode.handle = NULL;
squeezetiny/decode.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
squeezetiny/decode.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
squeezetiny/decode.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/decode.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/decode.c:#define LOCK_D   mutex_lock(ctx->decode.mutex)
squeezetiny/decode.c:#define UNLOCK_D mutex_unlock(ctx->decode.mutex)
squeezetiny/decode.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
squeezetiny/decode.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
squeezetiny/decode.c:	while (ctx->decode_running) {
squeezetiny/decode.c:		bytes = _buf_used(ctx->streambuf);
squeezetiny/decode.c:		toend = (ctx->stream.state <= DISCONNECT);
squeezetiny/decode.c:		space = _buf_space(ctx->outputbuf);
squeezetiny/decode.c:		if (ctx->decode.state == DECODE_RUNNING && ctx->codec) {
squeezetiny/decode.c:				min_space = ctx->codec->min_space;
squeezetiny/decode.c:				min_space = ctx->process.max_out_frames * BYTES_PER_FRAME;
squeezetiny/decode.c:			if (space > min_space && (bytes > ctx->codec->min_read_bytes || toend)) {
squeezetiny/decode.c:				ctx->decode.state = ctx->codec->decode(ctx);
squeezetiny/decode.c:					if (ctx->process.in_frames) {
squeezetiny/decode.c:					if (ctx->decode.state == DECODE_COMPLETE) {
squeezetiny/decode.c:				if (ctx->decode.state != DECODE_RUNNING) {
squeezetiny/decode.c:					LOG_INFO("decode %s", ctx->decode.state == DECODE_COMPLETE ? "complete" : "error");
squeezetiny/decode.c:					if (ctx->output.fade_mode) _checkfade(false, ctx);
squeezetiny/decode.c:	mutex_create(ctx->decode.mutex);
squeezetiny/decode.c:	ctx->decode_running = true;
squeezetiny/decode.c:	ctx->decode.new_stream = true;
squeezetiny/decode.c:	ctx->decode.state = DECODE_STOPPED;
squeezetiny/decode.c:	ctx->decode.handle = NULL;
squeezetiny/decode.c:	ctx->decode.process_handle = NULL;
squeezetiny/decode.c:		ctx->decode.direct = true;
squeezetiny/decode.c:		ctx->decode.process = false;
squeezetiny/decode.c:	pthread_create(&ctx->decode_thread, &attr, (void *(*)(void*)) decode_thread, ctx);
squeezetiny/decode.c:	if (ctx->codec) {
squeezetiny/decode.c:		ctx->codec->close(ctx);
squeezetiny/decode.c:		ctx->codec = NULL;
squeezetiny/decode.c:	ctx->decode_running = false;
squeezetiny/decode.c:	pthread_join(ctx->decode_thread, NULL);
squeezetiny/decode.c:	mutex_destroy(ctx->decode.mutex);
squeezetiny/decode.c:	ctx->decode.state = DECODE_STOPPED;
squeezetiny/decode.c:		if (ctx->decode.process) {
squeezetiny/decode.c:			sample_rate = process_newstream(&ctx->decode.direct, sample_rate, supported_rates, ctx);
squeezetiny/decode.c:	ctx->decode.new_stream = true;
squeezetiny/decode.c:	ctx->decode.state = DECODE_STOPPED;
squeezetiny/decode.c:		ctx->decode.direct = true; // potentially changed within codec when processing enabled
squeezetiny/decode.c:			if (ctx->codec && ctx->codec != codecs[i]) {
squeezetiny/decode.c:				LOG_DEBUG("closing codec: '%c'", ctx->codec->id);
squeezetiny/decode.c:				ctx->codec->close(ctx);
squeezetiny/decode.c:			ctx->codec = codecs[i];
squeezetiny/decode.c:			ctx->codec->open(sample_size, sample_rate, channels, endianness, ctx);
squeezetiny/decode.c:			ctx->decode.state = DECODE_READY;
squeezetiny/faad.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
squeezetiny/faad.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
squeezetiny/faad.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/faad.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/faad.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
squeezetiny/faad.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/faad.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
squeezetiny/faad.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
squeezetiny/faad.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/faad.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/faad.c:	struct faad *a = ctx->decode.handle;
squeezetiny/faad.c:	size_t bytes = min(_buf_used(ctx->streambuf), _buf_cont_read(ctx->streambuf));
squeezetiny/faad.c:		len = unpackN((u32_t *)ctx->streambuf->readp);
squeezetiny/faad.c:		memcpy(type, ctx->streambuf->readp + 4, 4);
squeezetiny/faad.c:			u8_t *ptr = ctx->streambuf->readp + 12;
squeezetiny/faad.c:			u8_t *ptr = ctx->streambuf->readp + 12;
squeezetiny/faad.c:			memcpy(a->stsc, ctx->streambuf->readp + 12, len - 12);
squeezetiny/faad.c:			u8_t *ptr = ctx->streambuf->readp + 12;
squeezetiny/faad.c:			_buf_inc_readp(ctx->streambuf, 8);
squeezetiny/faad.c:						_buf_inc_readp(ctx->streambuf, skip);
squeezetiny/faad.c:			u8_t *ptr = ctx->streambuf->readp + 8;
squeezetiny/faad.c:			_buf_inc_readp(ctx->streambuf, consume);
squeezetiny/faad.c:			_buf_inc_readp(ctx->streambuf, bytes);
squeezetiny/faad.c:		} else if (len > bytes && len <= _buf_used(ctx->streambuf)) {
squeezetiny/faad.c:			memcpy(buf, ctx->streambuf->readp, bytes);
squeezetiny/faad.c:			memmove(ctx->streambuf->buf + bytes, ctx->streambuf->buf, ctx->streambuf->writep - ctx->streambuf->buf);
squeezetiny/faad.c:			memcpy(ctx->streambuf->buf, buf, bytes);
squeezetiny/faad.c:			_buf_inc_writep(ctx->streambuf, bytes);
squeezetiny/faad.c:		 } else if (len >= ctx->streambuf->size) {
squeezetiny/faad.c:			LOG_ERROR("[%p]: atom %s too large for buffer %u %u", ctx, type, len, ctx->streambuf->size);
squeezetiny/faad.c:	struct faad *a = ctx->decode.handle;
squeezetiny/faad.c:	bytes_total = _buf_used(ctx->streambuf);
squeezetiny/faad.c:	bytes_wrap  = min(bytes_total, _buf_cont_read(ctx->streambuf));
squeezetiny/faad.c:	if (ctx->stream.state <= DISCONNECT && !bytes_total) {
squeezetiny/faad.c:		_buf_inc_readp(ctx->streambuf, consume);
squeezetiny/faad.c:	if (ctx->decode.new_stream) {
squeezetiny/faad.c:			while (bytes_wrap >= 2 && (*(ctx->streambuf->readp) != 0xFF || (*(ctx->streambuf->readp + 1) & 0xF6) != 0xF0)) {
squeezetiny/faad.c:				_buf_inc_readp(ctx->streambuf, 1);
squeezetiny/faad.c:				long n = NEAAC(&ga, Init, a->hAac, ctx->streambuf->readp, bytes_wrap, &a->samplerate, &a->channels);
squeezetiny/faad.c:					_buf_inc_readp(ctx->streambuf, n);
squeezetiny/faad.c:			bytes_total = _buf_used(ctx->streambuf);
squeezetiny/faad.c:			bytes_wrap  = min(bytes_total, _buf_cont_read(ctx->streambuf));
squeezetiny/faad.c:			ctx->output.current_sample_rate = decode_newstream(a->samplerate, ctx->output.supported_rates, ctx);
squeezetiny/faad.c:			ctx->output.track_start = ctx->outputbuf->writep;
squeezetiny/faad.c:			if (ctx->output.fade_mode) _checkfade(true, ctx);
squeezetiny/faad.c:			ctx->decode.new_stream = false;
squeezetiny/faad.c:		memcpy(buf, ctx->streambuf->readp, bytes_wrap);
squeezetiny/faad.c:		memcpy(buf + bytes_wrap, ctx->streambuf->buf, WRAPBUF_LEN - bytes_wrap);
squeezetiny/faad.c:		iptr = NEAAC(&ga, Decode, a->hAac, &info, ctx->streambuf->readp, bytes_wrap);
squeezetiny/faad.c:				_buf_inc_readp(ctx->streambuf, skip);
squeezetiny/faad.c:		_buf_inc_readp(ctx->streambuf, info.bytesconsumed);
squeezetiny/faad.c:			f = _buf_cont_write(ctx->outputbuf) / BYTES_PER_FRAME;
squeezetiny/faad.c:			optr = (s16_t *)ctx->outputbuf->writep;
squeezetiny/faad.c:			f = ctx->process.max_in_frames;
squeezetiny/faad.c:			optr = (s16_t *)ctx->process.inbuf;
squeezetiny/faad.c:			_buf_inc_writep(ctx->outputbuf, f * BYTES_PER_FRAME);
squeezetiny/faad.c:			ctx->process.in_frames = f;
squeezetiny/faad.c:	struct faad *a = ctx->decode.handle;
squeezetiny/faad.c:		a = ctx->decode.handle = malloc(sizeof(struct faad));
squeezetiny/faad.c:	struct faad *a = ctx->decode.handle;
squeezetiny/faad.c:	ctx->decode.handle = NULL;
squeezetiny/resample.c:	struct soxr *r = ctx->decode.process_handle;
squeezetiny/resample.c:		SOXR(&gr, process, r->resampler, ctx->process.inbuf, ctx->process.in_frames, &idone, ctx->process.outbuf, ctx->process.max_out_frames, &odone);
squeezetiny/resample.c:	if (idone != ctx->process.in_frames) {
squeezetiny/resample.c:				  ctx, (unsigned)idone, ctx->process.in_frames, (unsigned)odone, ctx->process.max_out_frames);
squeezetiny/resample.c:	ctx->process.out_frames = odone;
squeezetiny/resample.c:	ctx->process.total_in  += idone;
squeezetiny/resample.c:	ctx->process.total_out += odone;
squeezetiny/resample.c:	struct soxr *r = ctx->decode.process_handle;
squeezetiny/resample.c:	soxr_error_t error = SOXR(&gr, process, r->resampler, NULL, 0, NULL, ctx->process.outbuf, ctx->process.max_out_frames, &odone);
squeezetiny/resample.c:	ctx->process.out_frames = odone;
squeezetiny/resample.c:	ctx->process.total_out += odone;
squeezetiny/resample.c:	struct soxr *r = ctx->decode.process_handle;
squeezetiny/resample.c:	ctx->process.in_sample_rate = raw_sample_rate;
squeezetiny/resample.c:	ctx->process.out_sample_rate = outrate;
squeezetiny/resample.c:	struct soxr *r = ctx->decode.process_handle;
squeezetiny/resample.c:	r = ctx->decode.process_handle = malloc(sizeof(struct soxr));
squeezetiny/resample.c:	if (ctx->decode.process_handle) free(ctx->decode.process_handle);
squeezetiny/main.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
squeezetiny/main.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
squeezetiny/main.c:#define LOCK_D   mutex_lock(ctx->decode.mutex)
squeezetiny/main.c:#define UNLOCK_D mutex_unlock(ctx->decode.mutex)
squeezetiny/main.c:#define LOCK_P   mutex_lock(ctx->mutex)
squeezetiny/main.c:#define UNLOCK_P mutex_unlock(ctx->mutex)
squeezetiny/main.c:	ctx->callback = NULL;
squeezetiny/main.c:	ctx->in_use = false;
squeezetiny/main.c:	if (ctx->cli_sock > 0) return true;
squeezetiny/main.c:	ctx->cli_sock = socket(AF_INET, SOCK_STREAM, 0);
squeezetiny/main.c:	set_nonblock(ctx->cli_sock);
squeezetiny/main.c:	set_nosigpipe(ctx->cli_sock);
squeezetiny/main.c:	addr.sin_addr.s_addr = ctx->slimproto_ip;
squeezetiny/main.c:	addr.sin_port = htons(ctx->cli_port);
squeezetiny/main.c:	if (connect_timeout(ctx->cli_sock, (struct sockaddr *) &addr, sizeof(addr), 50))  {
squeezetiny/main.c:		ctx->cli_sock = -1;
squeezetiny/main.c:	LOG_INFO("[%p]: opened CLI socket %d", ctx, ctx->cli_sock);
squeezetiny/main.c:	mutex_lock(ctx->cli_mutex);
squeezetiny/main.c:		mutex_unlock(ctx->cli_mutex);
squeezetiny/main.c:	ctx->cli_timeout = gettime_ms() + CLI_KEEP_DURATION;
squeezetiny/main.c:	send_packet((u8_t*) packet, len, ctx->cli_sock);
squeezetiny/main.c:		FD_SET(ctx->cli_sock, &rfds);
squeezetiny/main.c:		k = select(ctx->cli_sock + 1, &rfds, NULL, NULL, &timeout);
squeezetiny/main.c:		k = recv(ctx->cli_sock, packet + len, CLI_PACKET - len, 0);
squeezetiny/main.c:	mutex_unlock(ctx->cli_mutex);
squeezetiny/main.c:	if (!handle || !ctx->in_use) {
squeezetiny/main.c:	sprintf(cmd, "%s mode", ctx->cli_id);
squeezetiny/main.c:	if (!handle || !ctx->in_use) {
squeezetiny/main.c:	sprintf(cmd, "%s status - 2 tags:xcfldatgrKN", ctx->cli_id);
squeezetiny/main.c:				snprintf(metadata->artwork, _STR_LEN_, "http://%s:%s/music/%s/cover.jpg", ctx->server_ip, ctx->server_port, p);
squeezetiny/main.c:			snprintf(artwork, _STR_LEN_, "http://%s:%s%s", ctx->server_ip, ctx->server_port, metadata->artwork);
squeezetiny/main.c:	if (!handle || !ctx->in_use) {
squeezetiny/main.c:	sprintf(cmd, "%s time", ctx->cli_id);
squeezetiny/main.c:	if (!handle || !ctx->in_use) {
squeezetiny/main.c:	sprintf(cmd, "%s time %s", ctx->cli_id, pos);
squeezetiny/main.c:	if (!ctx->running || !ctx->on || !handle || !ctx->in_use) return;
squeezetiny/main.c:			sprintf(cmd, "%s pause", ctx->cli_id);
squeezetiny/main.c:			sprintf(cmd, "%s play", ctx->cli_id);
squeezetiny/main.c:			sprintf(cmd, "%s mode", ctx->cli_id);
squeezetiny/main.c:				sprintf(cmd, "%s pause %d", ctx->cli_id, strstr(rsp, "pause") ? 0 : 1);
squeezetiny/main.c:				sprintf(cmd, "%s pause", ctx->cli_id);
squeezetiny/main.c:			sprintf(cmd, "%s stop", ctx->cli_id);
squeezetiny/main.c:			if (strstr(param, "up")) sprintf(cmd, "%s mixer volume +5", ctx->cli_id);
squeezetiny/main.c:			else if (strstr(param, "down")) sprintf(cmd, "%s mixer volume -5", ctx->cli_id);
squeezetiny/main.c:				 else sprintf(cmd, "%s mixer volume %s", ctx->cli_id, (char*) param);
squeezetiny/main.c:			sprintf(cmd, "%s mixer muting toggle", ctx->cli_id);
squeezetiny/main.c:			//sprintf(cmd, "%s playlist index -1", ctx->cli_id);
squeezetiny/main.c:			sprintf(cmd, "%s button jump_rew", ctx->cli_id);
squeezetiny/main.c:			sprintf(cmd, "%s playlist index +1", ctx->cli_id);
squeezetiny/main.c:			sprintf(cmd, "%s playlist shuffle 1", ctx->cli_id);
squeezetiny/main.c:			sprintf(cmd, "%s time %+d", ctx->cli_id, *((s16_t*) param));
squeezetiny/main.c:			sprintf(cmd, "%s power 0", ctx->cli_id);
squeezetiny/main.c:    ctx->self = ctx_i + 1;
squeezetiny/main.c:    ctx->on = false;
squeezetiny/main.c:    ctx->callback = callback;
squeezetiny/main.c:    ctx->MR = MR;
squeezetiny/main.c:    memcpy(&ctx->config, param, sizeof(sq_dev_param_t));
squeezetiny/main.c:    sprintf(ctx->cli_id, "%02x:%02x:%02x:%02x:%02x:%02x",
squeezetiny/main.c:                         ctx->config.mac[0], ctx->config.mac[1], ctx->config.mac[2],
squeezetiny/main.c:                         ctx->config.mac[3], ctx->config.mac[4], ctx->config.mac[5]);
squeezetiny/main.c:    if (stream_thread_init(ctx->config.streambuf_size, ctx) && output_huebridge_thread_init(huebridgecl, ctx->config.outputbuf_size, ctx)) {
squeezetiny/main.c:        if (ctx->stream_running) stream_close(ctx);
squeezetiny/opus.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
squeezetiny/opus.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
squeezetiny/opus.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/opus.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/opus.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
squeezetiny/opus.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/opus.c:#define LOCK_O_not_direct   if (!ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
squeezetiny/opus.c:#define UNLOCK_O_not_direct if (!ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/opus.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
squeezetiny/opus.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
squeezetiny/opus.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/opus.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/opus.c:	bytes = min(_buf_used(ctx->streambuf), _buf_cont_read(ctx->streambuf));
squeezetiny/opus.c:	memcpy(ptr, ctx->streambuf->readp, bytes);
squeezetiny/opus.c:	_buf_inc_readp(ctx->streambuf, bytes);
squeezetiny/opus.c:	struct opus *u = ctx->decode.handle;
squeezetiny/opus.c:		frames = min(_buf_space(ctx->outputbuf), _buf_cont_write(ctx->outputbuf)) / BYTES_PER_FRAME;
squeezetiny/opus.c:		frames = ctx->process.max_in_frames;
squeezetiny/opus.c:	if (!frames && ctx->stream.state <= DISCONNECT) {
squeezetiny/opus.c:	if (ctx->decode.new_stream) {
squeezetiny/opus.c:		ctx->output.current_sample_rate = decode_newstream(48000, ctx->output.supported_rates, ctx);
squeezetiny/opus.c:		ctx->output.track_start = ctx->outputbuf->writep;
squeezetiny/opus.c:		if (ctx->output.fade_mode) _checkfade(true, ctx);
squeezetiny/opus.c:		ctx->decode.new_stream = false;
squeezetiny/opus.c:			frames = ctx->process.max_in_frames;
squeezetiny/opus.c:		write_buf = ctx->outputbuf->writep;
squeezetiny/opus.c:		write_buf = ctx->process.inbuf;
squeezetiny/opus.c:			_buf_inc_writep(ctx->outputbuf, frames * BYTES_PER_FRAME);
squeezetiny/opus.c:			ctx->process.in_frames = frames;
squeezetiny/opus.c:		if (ctx->stream.state <= DISCONNECT) {
squeezetiny/opus.c:	struct opus *u = ctx->decode.handle;
squeezetiny/opus.c:		u = ctx->decode.handle = malloc(sizeof(struct opus));
squeezetiny/opus.c:	struct opus *u = ctx->decode.handle;
squeezetiny/opus.c:	ctx->decode.handle = NULL;
squeezetiny/output_huebridge.c:#define LOCK   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/output_huebridge.c:#define UNLOCK mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/output_huebridge.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
squeezetiny/output_huebridge.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
squeezetiny/output_huebridge.c:        if (ctx->output.fade == FADE_ACTIVE && ctx->output.fade_dir == FADE_CROSS && *cross_ptr) {
squeezetiny/output_huebridge.c:            _apply_cross(ctx->outputbuf, out_frames, cross_gain_in, cross_gain_out, cross_ptr);
squeezetiny/output_huebridge.c:        obuf = ctx->outputbuf->readp;
squeezetiny/output_huebridge.c:        obuf = ctx->silencebuf;
squeezetiny/output_huebridge.c:    _scale_and_pack_frames((ctx->output.buf + ctx->output.buf_frames * BYTES_PER_FRAME), (s32_t*)(void *)obuf, out_frames, gainL, gainR, flags, ctx->output.format);
squeezetiny/output_huebridge.c:    ctx->output.buf_frames += out_frames;
squeezetiny/output_huebridge.c:    free(ctx->output.buf);
squeezetiny/output_huebridge.c:    while (ctx->output_running) {
squeezetiny/output_huebridge.c:        if (ctx->output.state >= OUTPUT_BUFFER && huebridge_accept_frames(ctx->output.device)) {
squeezetiny/output_huebridge.c:            if (ctx->output.buf_frames) {
squeezetiny/output_huebridge.c:                huebridge_process_chunk(ctx->output.device, ctx->output.buf, ctx->output.buf_frames, &playtime);
squeezetiny/output_huebridge.c:                if (ctx->output.detect_start_time) {
squeezetiny/output_huebridge.c:                    ctx->output.detect_start_time = false;
squeezetiny/output_huebridge.c:                    ctx->output.track_start_time = gettime_ms();
squeezetiny/output_huebridge.c:                    LOG_INFO("[%p]: track actual start time:%u (gap:%d)", ctx, ctx->output.track_start_time,
squeezetiny/output_huebridge.c:                             (s32_t) (ctx->output.track_start_time - ctx->output.start_at));
squeezetiny/output_huebridge.c:                ctx->output.buf_frames = 0;
squeezetiny/output_huebridge.c:        ctx->output.updated = gettime_ms();
squeezetiny/output_huebridge.c:        ctx->output.device_frames = 0;
squeezetiny/output_huebridge.c:        ctx->output.frames_played_dmp = ctx->output.frames_played;
squeezetiny/output_huebridge.c:    memset(&ctx->output, 0, sizeof(ctx->output));
squeezetiny/output_huebridge.c:    ctx->output.buf = malloc(FRAMES_PER_BLOCK * BYTES_PER_FRAME);
squeezetiny/output_huebridge.c:    if (!ctx->output.buf) {
squeezetiny/output_huebridge.c:    ctx->output_running = true;
squeezetiny/output_huebridge.c:    ctx->output.buf_frames = 0;
squeezetiny/output_huebridge.c:    ctx->output.start_frames = FRAMES_PER_BLOCK * 2;
squeezetiny/output_huebridge.c:    ctx->output.write_cb = &_huebridge_write_frames;
squeezetiny/output_huebridge.c:    pthread_create(&ctx->output_thread, &attr, (void *(*)(void*)) &output_huebridge_thread, ctx);
squeezetiny/alac.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
squeezetiny/alac.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
squeezetiny/alac.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/alac.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/alac.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
squeezetiny/alac.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/alac.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
squeezetiny/alac.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
squeezetiny/alac.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/alac.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/alac.c:	struct alac *l = ctx->decode.handle;
squeezetiny/alac.c:	size_t bytes = min(_buf_used(ctx->streambuf), _buf_cont_read(ctx->streambuf));
squeezetiny/alac.c:		len = unpackN((u32_t *)ctx->streambuf->readp);
squeezetiny/alac.c:		memcpy(type, ctx->streambuf->readp + 4, 4);
squeezetiny/alac.c:			u8_t *ptr = ctx->streambuf->readp + 36;
squeezetiny/alac.c:			u8_t *ptr = ctx->streambuf->readp + 12;
squeezetiny/alac.c:			u8_t *ptr = ctx->streambuf->readp + 12;
squeezetiny/alac.c:			memcpy(l->stsc, ctx->streambuf->readp + 12, len - 12);
squeezetiny/alac.c:			u8_t *ptr = ctx->streambuf->readp + 12;
squeezetiny/alac.c:			_buf_inc_readp(ctx->streambuf, 8);
squeezetiny/alac.c:						_buf_inc_readp(ctx->streambuf, skip);
squeezetiny/alac.c:			u8_t *ptr = ctx->streambuf->readp + 8;
squeezetiny/alac.c:			_buf_inc_readp(ctx->streambuf, consume);
squeezetiny/alac.c:			_buf_inc_readp(ctx->streambuf, bytes);
squeezetiny/alac.c:		} else if (len >= ctx->streambuf->size) {
squeezetiny/alac.c:			LOG_ERROR("[%p]: atom %s too large for buffer %u %u", ctx, type, len, ctx->streambuf->size);
squeezetiny/alac.c:			_buf_unwrap(ctx->streambuf, len);
squeezetiny/alac.c:	struct alac *l = ctx->decode.handle;
squeezetiny/alac.c:		u32_t consume = min(l->consume, _buf_used(ctx->streambuf));
squeezetiny/alac.c:		_buf_inc_readp(ctx->streambuf, consume);
squeezetiny/alac.c:	if (ctx->decode.new_stream) {
squeezetiny/alac.c:			bytes = min(_buf_used(ctx->streambuf), _buf_cont_read(ctx->streambuf));
squeezetiny/alac.c:			ctx->output.current_sample_rate = decode_newstream(l->sample_rate, ctx->output.supported_rates, ctx);
squeezetiny/alac.c:			ctx->output.track_start = ctx->outputbuf->writep;
squeezetiny/alac.c:			if (ctx->output.fade_mode) _checkfade(true, ctx);
squeezetiny/alac.c:			ctx->decode.new_stream = false;
squeezetiny/alac.c:	bytes = _buf_used(ctx->streambuf);
squeezetiny/alac.c:	if (ctx->stream.state <= DISCONNECT && (bytes == 0 || block_size == 0)) {
squeezetiny/alac.c:	bytes = min(bytes, _buf_cont_read(ctx->streambuf));
squeezetiny/alac.c:		memcpy(iptr, ctx->streambuf->readp, bytes);
squeezetiny/alac.c:		memcpy(iptr + bytes, ctx->streambuf->buf, block_size - bytes);
squeezetiny/alac.c:	} else iptr = ctx->streambuf->readp;
squeezetiny/alac.c:			if (_buf_used(ctx->streambuf) >= skip) {
squeezetiny/alac.c:				_buf_inc_readp(ctx->streambuf, skip);
squeezetiny/alac.c:		_buf_inc_readp(ctx->streambuf, block_size);
squeezetiny/alac.c:			f = min(frames, _buf_cont_write(ctx->outputbuf) / BYTES_PER_FRAME);
squeezetiny/alac.c:			optr = (s16_t *)ctx->outputbuf->writep;
squeezetiny/alac.c:			f = min(frames, ctx->process.max_in_frames - ctx->process.in_frames);
squeezetiny/alac.c:			optr = (s16_t *)((u8_t *) ctx->process.inbuf + ctx->process.in_frames * BYTES_PER_FRAME);
squeezetiny/alac.c:			_buf_inc_writep(ctx->outputbuf, f * BYTES_PER_FRAME);
squeezetiny/alac.c:			ctx->process.in_frames = f;
squeezetiny/alac.c:	struct alac *l = ctx->decode.handle;
squeezetiny/alac.c:		ctx->decode.handle = l;
squeezetiny/alac.c:	struct alac *l = ctx->decode.handle;
squeezetiny/alac.c:	ctx->decode.handle = NULL;
squeezetiny/flac.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
squeezetiny/flac.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
squeezetiny/flac.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/flac.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/flac.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
squeezetiny/flac.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/flac.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
squeezetiny/flac.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
squeezetiny/flac.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/flac.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/flac.c:	bytes = min(_buf_used(ctx->streambuf), _buf_cont_read(ctx->streambuf));
squeezetiny/flac.c:	end = (ctx->stream.state <= DISCONNECT && bytes == 0);
squeezetiny/flac.c:	memcpy(buffer, ctx->streambuf->readp, bytes);
squeezetiny/flac.c:	_buf_inc_readp(ctx->streambuf, bytes);
squeezetiny/flac.c:	if (ctx->decode.new_stream) {
squeezetiny/flac.c:		ctx->output.track_start = ctx->outputbuf->writep;
squeezetiny/flac.c:		ctx->decode.new_stream = false;
squeezetiny/flac.c:		ctx->output.current_sample_rate = decode_newstream(frame->header.sample_rate, ctx->output.supported_rates, ctx);
squeezetiny/flac.c:		if (ctx->output.fade_mode) _checkfade(true, ctx);
squeezetiny/flac.c:			optr = (s16_t *)ctx->outputbuf->writep;
squeezetiny/flac.c:			f = min(_buf_space(ctx->outputbuf), _buf_cont_write(ctx->outputbuf)) / BYTES_PER_FRAME;
squeezetiny/flac.c:			optr = (s16_t *)ctx->process.inbuf;
squeezetiny/flac.c:			f = ctx->process.max_in_frames;
squeezetiny/flac.c:			_buf_inc_writep(ctx->outputbuf, f * BYTES_PER_FRAME);
squeezetiny/flac.c:			ctx->process.in_frames = f;
squeezetiny/flac.c:	struct flac *f = ctx->decode.handle;
squeezetiny/flac.c:		f = ctx->decode.handle = malloc(sizeof(struct flac));
squeezetiny/flac.c:	struct flac *f = ctx->decode.handle;
squeezetiny/flac.c:	free(ctx->decode.handle);
squeezetiny/flac.c:	ctx->decode.handle = NULL;
squeezetiny/flac.c:	struct flac *f = ctx->decode.handle;
squeezetiny/slimproto.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
squeezetiny/slimproto.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
squeezetiny/slimproto.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/slimproto.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/slimproto.c:#define LOCK_D   mutex_lock(ctx->decode.mutex)
squeezetiny/slimproto.c:#define UNLOCK_D mutex_unlock(ctx->decode.mutex)
squeezetiny/slimproto.c:#define LOCK_P   mutex_lock(ctx->mutex)
squeezetiny/slimproto.c:#define UNLOCK_P mutex_unlock(ctx->mutex)
squeezetiny/slimproto.c:	if (ctx->callback) rc = ctx->callback(ctx->self, ctx->MR, action, param);
squeezetiny/slimproto.c:	packN(&pkt.bytes_received_H, (u64_t)ctx->status.stream_bytes >> 32);
squeezetiny/slimproto.c:	packN(&pkt.bytes_received_L, (u64_t)ctx->status.stream_bytes & 0xffffffff);
squeezetiny/slimproto.c:	send_packet((u8_t *)&pkt, sizeof(pkt), ctx->sock);
squeezetiny/slimproto.c:	send_packet((u8_t *)base_cap, strlen(base_cap), ctx->sock);
squeezetiny/slimproto.c:	send_packet((u8_t *)fixed_cap, strlen(fixed_cap), ctx->sock);
squeezetiny/slimproto.c:	send_packet((u8_t *)var_cap, strlen(var_cap), ctx->sock);
squeezetiny/slimproto.c:	if (ctx->status.frames_played > ctx->status.device_frames) {
squeezetiny/slimproto.c:		ms_played = (u32_t)(((u64_t)(ctx->status.frames_played - ctx->status.device_frames) * (u64_t)1000) / (u64_t)ctx->status.current_sample_rate);
squeezetiny/slimproto.c:		if (now > ctx->status.updated) ms_played += (now - ctx->status.updated);
squeezetiny/slimproto.c:		LOG_DEBUG("[%p]: ms fr:%u clk:%u (frames_played: %u device_frames: %u)", ctx, ms_played, now - ctx->output.start_at, ctx->status.frames_played, ctx->status.device_frames);
squeezetiny/slimproto.c:	} else if (ctx->status.frames_played && now > ctx->status.stream_start) {
squeezetiny/slimproto.c:		ms_played = now - ctx->status.stream_start;
squeezetiny/slimproto.c:		LOG_DEBUG("[%p]: ms_played: %u using elapsed time (frames_played: %u device_frames: %u)", ctx, ms_played, ctx->status.frames_played, ctx->status.device_frames);
squeezetiny/slimproto.c:	packN(&pkt.stream_buffer_fullness, ctx->status.stream_full);
squeezetiny/slimproto.c:	packN(&pkt.stream_buffer_size, ctx->status.stream_size);
squeezetiny/slimproto.c:	packN(&pkt.bytes_received_H, (u64_t)ctx->status.stream_bytes >> 32);
squeezetiny/slimproto.c:	packN(&pkt.bytes_received_L, (u64_t)ctx->status.stream_bytes & 0xffffffff);
squeezetiny/slimproto.c:	packN(&pkt.output_buffer_size, ctx->status.output_size);
squeezetiny/slimproto.c:	packN(&pkt.output_buffer_fullness, ctx->status.output_full);
squeezetiny/slimproto.c:				   ctx, (u32_t) ctx->status.stream_bytes, ctx->status.stream_full, ctx->status.output_full, ms_played, now - ctx->status.stream_start,
squeezetiny/slimproto.c:				   ms_played - now + ctx->status.stream_start, now - ctx->status.updated);
squeezetiny/slimproto.c:	send_packet((u8_t *)&pkt, sizeof(pkt), ctx->sock);
squeezetiny/slimproto.c:		ctx->status.frames_played = 0;
squeezetiny/slimproto.c:		buf_flush(ctx->streambuf);
squeezetiny/slimproto.c:		ctx->status.frames_played = 0;
squeezetiny/slimproto.c:		buf_flush(ctx->streambuf);
squeezetiny/slimproto.c:		if (ctx->last_command != 'q') ctx_callback(ctx, SQ_STOP, NULL);
squeezetiny/slimproto.c:			ctx->output.pause_frames = interval * ctx->status.current_sample_rate / 1000;
squeezetiny/slimproto.c:			ctx->output.state = interval ? OUTPUT_PAUSE_FRAMES : OUTPUT_STOPPED;
squeezetiny/slimproto.c:			ctx->output.skip_frames = interval * ctx->status.current_sample_rate / 1000;
squeezetiny/slimproto.c:			ctx->output.state = OUTPUT_SKIP_FRAMES;
squeezetiny/slimproto.c:			ctx->output.state = OUTPUT_RUNNING;
squeezetiny/slimproto.c:			ctx->output.start_at = jiffies;
squeezetiny/slimproto.c:			if (ip == 0) ip = ctx->slimproto_ip;
squeezetiny/slimproto.c:			ctx->autostart = strm->autostart - '0';
squeezetiny/slimproto.c:			ctx->output.threshold = strm->output_threshold;
squeezetiny/slimproto.c:			ctx->output.next_replay_gain = unpackN(&strm->replay_gain);
squeezetiny/slimproto.c:			ctx->output.fade_mode = strm->transition_type - '0';
squeezetiny/slimproto.c:			ctx->output.fade_secs = strm->transition_period;
squeezetiny/slimproto.c:			ctx->output.invert = (strm->flags & 0x03) == 0x03;
squeezetiny/slimproto.c:			ctx->output.channels = (strm->flags & 0x0c) >> 2;
squeezetiny/slimproto.c:			LOG_DEBUG("[%p]: set fade mode: %u, channels: %u, invert: %u", ctx, ctx->output.fade_mode, ctx->output.channels, ctx->output.invert);
squeezetiny/slimproto.c:				if (sample_rate > ctx->config.sample_rate) {
squeezetiny/slimproto.c:					 LOG_WARN("[%p]: Sample rate %u error suspected, forcing to %u", ctx, sample_rate, ctx->config.sample_rate);
squeezetiny/slimproto.c:					 sample_rate = ctx->config.sample_rate;
squeezetiny/slimproto.c:			} else if (ctx->autostart >= 2) {
squeezetiny/slimproto.c:			stream_sock(ip, port, strm->flags & 0x20, header, header_len, strm->threshold * 1024, ctx->autostart >= 2, ctx);
squeezetiny/slimproto.c:			ctx->sentSTMu = ctx->sentSTMo = ctx->sentSTMl = ctx->sentSTMd = false;
squeezetiny/slimproto.c:	ctx->last_command = strm->command;
squeezetiny/slimproto.c:	if (ctx->autostart > 1) {
squeezetiny/slimproto.c:		ctx->autostart -= 2;
squeezetiny/slimproto.c:		if (ctx->stream.state == STREAMING_WAIT) {
squeezetiny/slimproto.c:			ctx->stream.state = STREAMING_BUFFERING;
squeezetiny/slimproto.c:			ctx->stream.meta_interval = ctx->stream.meta_next = cont->metaint;
squeezetiny/slimproto.c:	ctx->on = (aude->enable_spdif) ? true : false;
squeezetiny/slimproto.c:	LOG_DEBUG("[%p] on/off using aude %d", ctx, ctx->on);
squeezetiny/slimproto.c:	ctx_callback(ctx, SQ_ONOFF, &ctx->on);
squeezetiny/slimproto.c:	if (ctx->config.soft_volume) {
squeezetiny/slimproto.c:		ctx->output.gainL = audg->adjust ? audg->gainL : FIXED_ONE;
squeezetiny/slimproto.c:		ctx->output.gainR = audg->adjust ? audg->gainR : FIXED_ONE;
squeezetiny/slimproto.c:	else ctx->output.gainL = ctx->output.gainR = FIXED_ONE;
squeezetiny/slimproto.c:			if (strlen(ctx->config.name)) {
squeezetiny/slimproto.c:				sendSETDName(ctx->config.name, ctx->sock);
squeezetiny/slimproto.c:			strncpy(ctx->config.name, setd->data, _STR_LEN_);
squeezetiny/slimproto.c:			ctx->config.name[_STR_LEN_ - 1] = '\0';
squeezetiny/slimproto.c:			sendSETDName(setd->data, ctx->sock);
squeezetiny/slimproto.c:			ctx_callback(ctx, SQ_SETNAME, (void*) ctx->config.name);
squeezetiny/slimproto.c:	ctx->new_server = serv->server_ip;
squeezetiny/slimproto.c:		if (!ctx->new_server_cap) {
squeezetiny/slimproto.c:			ctx->new_server_cap = malloc(SYNC_CAP_LEN + 10 + 1);
squeezetiny/slimproto.c:		ctx->new_server_cap[0] = '\0';
squeezetiny/slimproto.c:		strcat(ctx->new_server_cap, SYNC_CAP);
squeezetiny/slimproto.c:		strncat(ctx->new_server_cap, (const char *)(pkt + sizeof(struct serv_packet)), 10);
squeezetiny/slimproto.c:		if (ctx->new_server_cap) {
squeezetiny/slimproto.c:			free(ctx->new_server_cap);
squeezetiny/slimproto.c:			ctx->new_server_cap = NULL;
squeezetiny/slimproto.c:	ctx_callback(ctx, SQ_SETSERVER, (void*) &ctx->new_server);
squeezetiny/slimproto.c:	set_readwake_handles(ehandles, ctx->sock, ctx->wake_e);
squeezetiny/slimproto.c:	while (ctx->running && !ctx->new_server) {
squeezetiny/slimproto.c:					int n = recv(ctx->sock, ctx->slim_run.buffer + got, expect, 0);
squeezetiny/slimproto.c:						process(ctx->slim_run.buffer, got, ctx);
squeezetiny/slimproto.c:					int n = recv(ctx->sock, ctx->slim_run.buffer + got, 2 - got, 0);
squeezetiny/slimproto.c:						expect = ctx->slim_run.buffer[0] << 8 | ctx->slim_run.buffer[1]; // length pack 'n'
squeezetiny/slimproto.c:			if (ctx->cli_sock > 0 && (int) (gettime_ms() - ctx->cli_timeout) > 0) {
squeezetiny/slimproto.c:				if (!mutex_trylock(ctx->cli_mutex)) {
squeezetiny/slimproto.c:					LOG_INFO("[%p] Closing CLI socket %d", ctx, ctx->cli_sock);
squeezetiny/slimproto.c:					closesocket(ctx->cli_sock);
squeezetiny/slimproto.c:					ctx->cli_sock = -1;
squeezetiny/slimproto.c:					mutex_unlock(ctx->cli_mutex);
squeezetiny/slimproto.c:		if (wake || now - ctx->slim_run.last > 100 || ctx->slim_run.last > now) {
squeezetiny/slimproto.c:			ctx->slim_run.last = now;
squeezetiny/slimproto.c:			ctx->status.stream_full = _buf_used(ctx->streambuf);
squeezetiny/slimproto.c:			ctx->status.stream_size = ctx->streambuf->size;
squeezetiny/slimproto.c:			ctx->status.stream_bytes = ctx->stream.bytes;
squeezetiny/slimproto.c:			ctx->status.stream_state = ctx->stream.state;
squeezetiny/slimproto.c:			if (ctx->stream.state == DISCONNECT) {
squeezetiny/slimproto.c:				disconnect_code = ctx->stream.disconnect;
squeezetiny/slimproto.c:				ctx->stream.state = STOPPED;
squeezetiny/slimproto.c:			if (!ctx->stream.sent_headers &&
squeezetiny/slimproto.c:				(ctx->stream.state == STREAMING_HTTP || ctx->stream.state == STREAMING_WAIT || ctx->stream.state == STREAMING_BUFFERING)) {
squeezetiny/slimproto.c:				header_len = ctx->stream.header_len;
squeezetiny/slimproto.c:				memcpy(ctx->slim_run.header, ctx->stream.header, header_len);
squeezetiny/slimproto.c:				ctx->stream.sent_headers = true;
squeezetiny/slimproto.c:			if (ctx->stream.meta_send) {
squeezetiny/slimproto.c:				header_len = ctx->stream.header_len;
squeezetiny/slimproto.c:				memcpy(ctx->slim_run.header, ctx->stream.header, header_len);
squeezetiny/slimproto.c:				ctx->stream.meta_send = false;
squeezetiny/slimproto.c:			ctx->status.output_full = _buf_used(ctx->outputbuf);
squeezetiny/slimproto.c:			ctx->status.output_size = ctx->outputbuf->size;
squeezetiny/slimproto.c:			ctx->status.frames_played = ctx->output.frames_played_dmp;
squeezetiny/slimproto.c:			ctx->status.current_sample_rate = ctx->output.current_sample_rate;
squeezetiny/slimproto.c:			ctx->status.updated = ctx->output.updated;
squeezetiny/slimproto.c:			ctx->status.device_frames = ctx->output.device_frames;
squeezetiny/slimproto.c:			if (ctx->output.track_started) {
squeezetiny/slimproto.c:				ctx->output.track_started = false;
squeezetiny/slimproto.c:				ctx->status.stream_start = ctx->output.track_start_time;
squeezetiny/slimproto.c:				ctx_callback(ctx, SQ_STARTED, &ctx->output.track_start_time);
squeezetiny/slimproto.c:			if (ctx->output.state == OUTPUT_RUNNING && !ctx->sentSTMu && ctx->status.output_full == 0 && ctx->status.stream_state <= DISCONNECT) {
squeezetiny/slimproto.c:				ctx->sentSTMu = true;
squeezetiny/slimproto.c:			if (ctx->output.state == OUTPUT_RUNNING && !ctx->sentSTMo && ctx->status.output_full == 0 && ctx->status.stream_state == STREAMING_HTTP) {
squeezetiny/slimproto.c:				ctx->sentSTMo = true;
squeezetiny/slimproto.c:			if (ctx->decode.state == DECODE_RUNNING && now - ctx->status.last > 1000) {
squeezetiny/slimproto.c:				ctx->status.last = now;
squeezetiny/slimproto.c:			if ((ctx->status.stream_state == STREAMING_HTTP || ctx->status.stream_state == STREAMING_FILE || (ctx->status.stream_state == DISCONNECT && ctx->stream.disconnect == DISCONNECT_OK))
squeezetiny/slimproto.c:				&& !ctx->sentSTMl && ctx->decode.state == DECODE_READY) {
squeezetiny/slimproto.c:				if (ctx->autostart == 0) {
squeezetiny/slimproto.c:					ctx->decode.state = DECODE_RUNNING;
squeezetiny/slimproto.c:					ctx->sentSTMl = true;
squeezetiny/slimproto.c:				} else if (ctx->autostart == 1) {
squeezetiny/slimproto.c:					ctx->decode.state = DECODE_RUNNING;
squeezetiny/slimproto.c:					if (ctx->output.state == OUTPUT_STOPPED) {
squeezetiny/slimproto.c:						ctx->output.state = OUTPUT_BUFFER;
squeezetiny/slimproto.c:			if (ctx->decode.state == DECODE_COMPLETE || ctx->decode.state == DECODE_ERROR) {
squeezetiny/slimproto.c:				if (ctx->decode.state == DECODE_COMPLETE) _sendSTMd = true;
squeezetiny/slimproto.c:				if (ctx->decode.state == DECODE_ERROR)    _sendSTMn = true;
squeezetiny/slimproto.c:				ctx->decode.state = DECODE_STOPPED;
squeezetiny/slimproto.c:				if (ctx->status.stream_state == STREAMING_HTTP || ctx->status.stream_state == STREAMING_FILE) {
squeezetiny/slimproto.c:			if (_sendDSCO) sendDSCO(disconnect_code, ctx->sock);
squeezetiny/slimproto.c:			if (_sendRESP) sendRESP(ctx->slim_run.header, header_len, ctx->sock);
squeezetiny/slimproto.c:			if (_sendMETA) sendMETA(ctx->slim_run.header, header_len, ctx->sock);
squeezetiny/slimproto.c:	wake_signal(ctx->wake_e);
squeezetiny/slimproto.c:	ctx->cli_port = 9090;
squeezetiny/slimproto.c:	if (!ctx->slimproto_ip) d.sin_addr.s_addr = htonl(INADDR_BROADCAST);
squeezetiny/slimproto.c:	else d.sin_addr.s_addr = ctx->slimproto_ip;
squeezetiny/slimproto.c:				strncpy(ctx->server_version, p + 1, min(SERVER_VERSION_LEN, *p));
squeezetiny/slimproto.c:				ctx->server_version[min(SERVER_VERSION_LEN, *p)] = '\0';
squeezetiny/slimproto.c:				strncpy(ctx->server_port, p + 1, min(5, *p));
squeezetiny/slimproto.c:				ctx->server_port[min(6, *p)] = '\0';
squeezetiny/slimproto.c:				ctx->cli_port = atoi(p + 1);
squeezetiny/slimproto.c:			strcpy(ctx->server_ip, inet_ntoa(s.sin_addr));
squeezetiny/slimproto.c:	} while (s.sin_addr.s_addr == 0 && ctx->running);
squeezetiny/slimproto.c:	ctx->slimproto_ip =  s.sin_addr.s_addr;
squeezetiny/slimproto.c:	ctx->slimproto_port = ntohs(s.sin_port);
squeezetiny/slimproto.c:	ctx->serv_addr.sin_port = s.sin_port;
squeezetiny/slimproto.c:	ctx->serv_addr.sin_addr.s_addr = s.sin_addr.s_addr;
squeezetiny/slimproto.c:	ctx->serv_addr.sin_family = AF_INET;
squeezetiny/slimproto.c:	LOG_INFO("squeezelite [%p] <=> player [%p]", ctx, ctx->MR);
squeezetiny/slimproto.c:	LOG_INFO("[%p] connecting to %s:%d", ctx, inet_ntoa(ctx->serv_addr.sin_addr), ntohs(ctx->serv_addr.sin_port));
squeezetiny/slimproto.c:	while (ctx->running) {
squeezetiny/slimproto.c:		if (ctx->new_server) {
squeezetiny/slimproto.c:			ctx->slimproto_ip = ctx->new_server;
squeezetiny/slimproto.c:			ctx->new_server = 0;
squeezetiny/slimproto.c:			LOG_INFO("[%p] switching server to %s:%d", ctx, inet_ntoa(ctx->serv_addr.sin_addr), ntohs(ctx->serv_addr.sin_port));
squeezetiny/slimproto.c:		ctx->sock = socket(AF_INET, SOCK_STREAM, 0);
squeezetiny/slimproto.c:		set_nonblock(ctx->sock);
squeezetiny/slimproto.c:		set_nosigpipe(ctx->sock);
squeezetiny/slimproto.c:		if (connect_timeout(ctx->sock, (struct sockaddr *) &ctx->serv_addr, sizeof(ctx->serv_addr), 5*1000) != 0) {
squeezetiny/slimproto.c:			if (!strcmp(ctx->config.server, "?") && ++failed_connect > 5) {
squeezetiny/slimproto.c:				ctx->slimproto_ip = 0;
squeezetiny/slimproto.c:			ctx->var_cap[0] = '\0';
squeezetiny/slimproto.c:			if (ctx->new_server_cap) {
squeezetiny/slimproto.c:				strcat(ctx->var_cap, ctx->new_server_cap);
squeezetiny/slimproto.c:				free(ctx->new_server_cap);
squeezetiny/slimproto.c:				ctx->new_server_cap = NULL;
squeezetiny/slimproto.c:			sendHELO(reconnect, ctx->fixed_cap, ctx->var_cap, ctx->config.mac, ctx);
squeezetiny/slimproto.c:		mutex_lock(ctx->cli_mutex);
squeezetiny/slimproto.c:		if (ctx->cli_sock != -1) {
squeezetiny/slimproto.c:			closesocket(ctx->cli_sock);
squeezetiny/slimproto.c:			ctx->cli_sock = -1;
squeezetiny/slimproto.c:		mutex_unlock(ctx->cli_mutex);
squeezetiny/slimproto.c:		closesocket(ctx->sock);
squeezetiny/slimproto.c:		if (ctx->new_server_cap)	{
squeezetiny/slimproto.c:			free(ctx->new_server_cap);
squeezetiny/slimproto.c:			ctx->new_server_cap = NULL;
squeezetiny/slimproto.c:	LOG_INFO("[%p] slimproto stop for %s", ctx, ctx->config.name);
squeezetiny/slimproto.c:	ctx->running = false;
squeezetiny/slimproto.c:	pthread_join(ctx->thread, NULL);
squeezetiny/slimproto.c:	mutex_destroy(ctx->mutex);
squeezetiny/slimproto.c:	mutex_destroy(ctx->cli_mutex);
squeezetiny/slimproto.c:	wake_create(ctx->wake_e);
squeezetiny/slimproto.c:	mutex_create(ctx->mutex);
squeezetiny/slimproto.c:	mutex_create(ctx->cli_mutex);
squeezetiny/slimproto.c:	ctx->slimproto_ip = 0;
squeezetiny/slimproto.c:	ctx->slimproto_port = PORT;
squeezetiny/slimproto.c:	ctx->cli_sock = ctx->sock = -1;
squeezetiny/slimproto.c:	ctx->running = true;
squeezetiny/slimproto.c:	if (strcmp(ctx->config.server, "?")) {
squeezetiny/slimproto.c:		server_addr(ctx->config.server, &ctx->slimproto_ip, &ctx->slimproto_port);
squeezetiny/slimproto.c:	strcpy(ctx->var_cap, "");
squeezetiny/slimproto.c:	ctx->new_server_cap = NULL;
squeezetiny/slimproto.c:	sprintf(ctx->fixed_cap, ",MaxSampleRate=%u", soxr_loaded ? ctx->config.sample_rate : 44100);
squeezetiny/slimproto.c:	codec = buf = strdup(ctx->config.codecs);
squeezetiny/slimproto.c:				strcat(ctx->fixed_cap, ",");
squeezetiny/slimproto.c:				strcat(ctx->fixed_cap, codec);
squeezetiny/slimproto.c:	ctx->new_server = 0;
squeezetiny/slimproto.c:	pthread_create(&ctx->thread, &attr, (void *(*)(void*)) slimproto, ctx);
squeezetiny/output.c:#define LOCK   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/output.c:#define UNLOCK mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/output.c:        u8_t flags = ctx->output.channels;
squeezetiny/output.c:	s32_t gainL = ctx->output.current_replay_gain ? gain(ctx->output.gainL, ctx->output.current_replay_gain) : ctx->output.gainL;
squeezetiny/output.c:	s32_t gainR = ctx->output.current_replay_gain ? gain(ctx->output.gainR, ctx->output.current_replay_gain) : ctx->output.gainR;
squeezetiny/output.c:	frames = _buf_used(ctx->outputbuf) / BYTES_PER_FRAME;
squeezetiny/output.c:	if (ctx->output.state == OUTPUT_BUFFER && frames > ctx->output.threshold * ctx->output.current_sample_rate / 10 && frames > ctx->output.start_frames) {
squeezetiny/output.c:		ctx->output.state = OUTPUT_RUNNING;
squeezetiny/output.c:	if (ctx->output.state == OUTPUT_SKIP_FRAMES) {
squeezetiny/output.c:			frames_t skip = min(frames, ctx->output.skip_frames);
squeezetiny/output.c:			LOG_INFO("[%p]: skip %u of %u frames", ctx, skip, ctx->output.skip_frames);
squeezetiny/output.c:			ctx->output.frames_played += skip;
squeezetiny/output.c:				frames_t cont_frames = min(skip, _buf_cont_read(ctx->outputbuf) / BYTES_PER_FRAME);
squeezetiny/output.c:				_buf_inc_readp(ctx->outputbuf, cont_frames * BYTES_PER_FRAME);
squeezetiny/output.c:		ctx->output.state = OUTPUT_RUNNING;
squeezetiny/output.c:	if (ctx->output.state == OUTPUT_PAUSE_FRAMES) {
squeezetiny/output.c:		LOG_INFO("[%p]: pause %u frames", ctx, ctx->output.pause_frames);
squeezetiny/output.c:		if (ctx->output.pause_frames == 0) {
squeezetiny/output.c:			ctx->output.state = OUTPUT_RUNNING;
squeezetiny/output.c:			frames = min(avail, ctx->output.pause_frames);
squeezetiny/output.c:			ctx->output.pause_frames -= frames;
squeezetiny/output.c:		frames_t cont_frames = _buf_cont_read(ctx->outputbuf) / BYTES_PER_FRAME;
squeezetiny/output.c:		if (ctx->output.track_start && !silence) {
squeezetiny/output.c:			if (ctx->output.track_start == ctx->outputbuf->readp) {
squeezetiny/output.c:				LOG_INFO("[%p]: track start sample rate: %u replay_gain: %u", ctx, ctx->output.current_sample_rate, ctx->output.next_replay_gain);
squeezetiny/output.c:				ctx->output.frames_played = 0;
squeezetiny/output.c:				ctx->output.track_started = true;
squeezetiny/output.c:				ctx->output.detect_start_time = true;
squeezetiny/output.c:				if (ctx->output.fade == FADE_INACTIVE || ctx->output.fade_mode != FADE_CROSSFADE) {
squeezetiny/output.c:					ctx->output.current_replay_gain = ctx->output.next_replay_gain;
squeezetiny/output.c:				ctx->output.track_start = NULL;
squeezetiny/output.c:			} else if (ctx->output.track_start > ctx->outputbuf->readp) {
squeezetiny/output.c:				cont_frames = min(cont_frames, (ctx->output.track_start - ctx->outputbuf->readp) / BYTES_PER_FRAME);
squeezetiny/output.c:		if (ctx->output.fade && !silence) {
squeezetiny/output.c:			if (ctx->output.fade == FADE_DUE) {
squeezetiny/output.c:				if (ctx->output.fade_start == ctx->outputbuf->readp) {
squeezetiny/output.c:					ctx->output.fade = FADE_ACTIVE;
squeezetiny/output.c:				} else if (ctx->output.fade_start > ctx->outputbuf->readp) {
squeezetiny/output.c:					cont_frames = min(cont_frames, (ctx->output.fade_start - ctx->outputbuf->readp) / BYTES_PER_FRAME);
squeezetiny/output.c:			if (ctx->output.fade == FADE_ACTIVE) {
squeezetiny/output.c:				frames_t cur_f = ctx->outputbuf->readp >= ctx->output.fade_start ? (ctx->outputbuf->readp - ctx->output.fade_start) / BYTES_PER_FRAME :
squeezetiny/output.c:					(ctx->outputbuf->readp + ctx->outputbuf->size - ctx->output.fade_start) / BYTES_PER_FRAME;
squeezetiny/output.c:				frames_t dur_f = ctx->output.fade_end >= ctx->output.fade_start ? (ctx->output.fade_end - ctx->output.fade_start) / BYTES_PER_FRAME :
squeezetiny/output.c:					(ctx->output.fade_end + ctx->outputbuf->size - ctx->output.fade_start) / BYTES_PER_FRAME;
squeezetiny/output.c:					if (ctx->output.fade_mode == FADE_INOUT && ctx->output.fade_dir == FADE_DOWN) {
squeezetiny/output.c:						ctx->output.fade_dir = FADE_UP;
squeezetiny/output.c:						ctx->output.fade_start = ctx->outputbuf->readp;
squeezetiny/output.c:						ctx->output.fade_end = ctx->outputbuf->readp + dur_f * BYTES_PER_FRAME;
squeezetiny/output.c:						if (ctx->output.fade_end >= ctx->outputbuf->wrap) {
squeezetiny/output.c:							ctx->output.fade_end -= ctx->outputbuf->size;
squeezetiny/output.c:					} else if (ctx->output.fade_mode == FADE_CROSSFADE) {
squeezetiny/output.c:						if (_buf_used(ctx->outputbuf) >= dur_f * BYTES_PER_FRAME) {
squeezetiny/output.c:							_buf_inc_readp(ctx->outputbuf, dur_f * BYTES_PER_FRAME);
squeezetiny/output.c:						ctx->output.fade = FADE_INACTIVE;
squeezetiny/output.c:						ctx->output.current_replay_gain = ctx->output.next_replay_gain;
squeezetiny/output.c:						ctx->output.fade = FADE_INACTIVE;
squeezetiny/output.c:				if (ctx->output.fade) {
squeezetiny/output.c:					if (ctx->output.fade_end > ctx->outputbuf->readp) {
squeezetiny/output.c:						cont_frames = min(cont_frames, (ctx->output.fade_end - ctx->outputbuf->readp) / BYTES_PER_FRAME);
squeezetiny/output.c:					if (ctx->output.fade_dir == FADE_UP || ctx->output.fade_dir == FADE_DOWN) {
squeezetiny/output.c:						if (ctx->output.fade_dir == FADE_DOWN) {
squeezetiny/output.c:					if (ctx->output.fade_dir == FADE_CROSS) {
squeezetiny/output.c:						if (_buf_used(ctx->outputbuf) / BYTES_PER_FRAME > dur_f + size) {
squeezetiny/output.c:							if (ctx->output.current_replay_gain) {
squeezetiny/output.c:								cross_gain_out = gain(cross_gain_out, ctx->output.current_replay_gain);
squeezetiny/output.c:							if (ctx->output.next_replay_gain) {
squeezetiny/output.c:								cross_gain_in = gain(cross_gain_in, ctx->output.next_replay_gain);
squeezetiny/output.c:							gainL = ctx->output.gainL;
squeezetiny/output.c:							gainR = ctx->output.gainR;
squeezetiny/output.c:							cross_ptr = (s32_t *)(ctx->output.fade_end + cur_f * BYTES_PER_FRAME);
squeezetiny/output.c:							ctx->output.fade = FADE_INACTIVE;
squeezetiny/output.c:		if (ctx->output.channels & 0x01) gainR |= MONO_FLAG;
squeezetiny/output.c:		if (ctx->output.channels & 0x02) gainL |= MONO_FLAG;
squeezetiny/output.c:		wrote = ctx->output.write_cb(ctx, out_frames, silence, gainL, gainR, flags, cross_gain_in, cross_gain_out, &cross_ptr);
squeezetiny/output.c:			_buf_inc_readp(ctx->outputbuf, out_frames * BYTES_PER_FRAME);
squeezetiny/output.c:			ctx->output.frames_played += out_frames;
squeezetiny/output.c:	LOG_INFO("[%p]: fade mode: %u duration: %u %s", ctx, ctx->output.fade_mode, ctx->output.fade_secs, start ? "track-start" : "track-end");
squeezetiny/output.c:	bytes = ctx->output.current_sample_rate * BYTES_PER_FRAME * ctx->output.fade_secs;
squeezetiny/output.c:	if (ctx->output.fade_mode == FADE_INOUT) {
squeezetiny/output.c:	if (start && (ctx->output.fade_mode == FADE_IN || (ctx->output.fade_mode == FADE_INOUT && _buf_used(ctx->outputbuf) == 0))) {
squeezetiny/output.c:		bytes = min(bytes, ctx->outputbuf->size - BYTES_PER_FRAME); // shorter than full buffer otherwise start and end align
squeezetiny/output.c:		ctx->output.fade = FADE_DUE;
squeezetiny/output.c:		ctx->output.fade_dir = FADE_UP;
squeezetiny/output.c:		ctx->output.fade_start = ctx->outputbuf->writep;
squeezetiny/output.c:		ctx->output.fade_end = ctx->output.fade_start + bytes;
squeezetiny/output.c:		if (ctx->output.fade_end >= ctx->outputbuf->wrap) {
squeezetiny/output.c:			ctx->output.fade_end -= ctx->outputbuf->size;
squeezetiny/output.c:	if (!start && (ctx->output.fade_mode == FADE_OUT || ctx->output.fade_mode == FADE_INOUT)) {
squeezetiny/output.c:		bytes = min(_buf_used(ctx->outputbuf), bytes);
squeezetiny/output.c:		LOG_INFO("[%p]: fade %s: %u frames", ctx, ctx->output.fade_mode == FADE_INOUT ? "IN-OUT" : "OUT", bytes / BYTES_PER_FRAME);
squeezetiny/output.c:		ctx->output.fade = FADE_DUE;
squeezetiny/output.c:		ctx->output.fade_dir = FADE_DOWN;
squeezetiny/output.c:		ctx->output.fade_start = ctx->outputbuf->writep - bytes;
squeezetiny/output.c:		if (ctx->output.fade_start < ctx->outputbuf->buf) {
squeezetiny/output.c:			ctx->output.fade_start += ctx->outputbuf->size;
squeezetiny/output.c:		ctx->output.fade_end = ctx->outputbuf->writep;
squeezetiny/output.c:	if (start && ctx->output.fade_mode == FADE_CROSSFADE) {
squeezetiny/output.c:		if (_buf_used(ctx->outputbuf) != 0) {
squeezetiny/output.c:			bytes = min(bytes, _buf_used(ctx->outputbuf));               // max of current remaining samples from previous track
squeezetiny/output.c:			bytes = min(bytes, (frames_t)(ctx->outputbuf->size * 0.9));  // max of 90% of outputbuf as we consume additional buffer during crossfade
squeezetiny/output.c:			ctx->output.fade = FADE_DUE;
squeezetiny/output.c:			ctx->output.fade_dir = FADE_CROSS;
squeezetiny/output.c:			ctx->output.fade_start = ctx->outputbuf->writep - bytes;
squeezetiny/output.c:			if (ctx->output.fade_start < ctx->outputbuf->buf) {
squeezetiny/output.c:				ctx->output.fade_start += ctx->outputbuf->size;
squeezetiny/output.c:			ctx->output.fade_end = ctx->outputbuf->writep;
squeezetiny/output.c:			ctx->output.track_start = ctx->output.fade_start;
squeezetiny/output.c:		else if (ctx->outputbuf->size == OUTPUTBUF_SIZE && ctx->outputbuf->readp == ctx->outputbuf->buf) {
squeezetiny/output.c:			_buf_resize(ctx->outputbuf, OUTPUTBUF_SIZE_CROSSFADE);
squeezetiny/output.c:			touch_memory(ctx->outputbuf->buf, ctx->outputbuf->size);
squeezetiny/output.c:	ctx->outputbuf = &ctx->__o_buf;
squeezetiny/output.c:	buf_init(ctx->outputbuf, outputbuf_size);
squeezetiny/output.c:	if (!ctx->outputbuf->buf) {
squeezetiny/output.c:	ctx->silencebuf = malloc(MAX_SILENCE_FRAMES * BYTES_PER_FRAME);
squeezetiny/output.c:	if (!ctx->silencebuf) {
squeezetiny/output.c:	memset(ctx->silencebuf, 0, MAX_SILENCE_FRAMES * BYTES_PER_FRAME);
squeezetiny/output.c:	ctx->output.state = OUTPUT_STOPPED;
squeezetiny/output.c:	ctx->output.fade = FADE_INACTIVE;
squeezetiny/output.c:	ctx->output.device = device;
squeezetiny/output.c:	ctx->output.error_opening = false;
squeezetiny/output.c:	ctx->output.detect_start_time = false;
squeezetiny/output.c:	ctx->output.current_sample_rate = ctx->output.default_sample_rate = sample_rate;
squeezetiny/output.c:	ctx->output.supported_rates[0] = sample_rate;
squeezetiny/output.c:	ctx->output.supported_rates[1] = 0;
squeezetiny/output.c:	ctx->output_running = false;
squeezetiny/output.c:	pthread_join(ctx->output_thread, NULL);
squeezetiny/output.c:	buf_destroy(ctx->outputbuf);
squeezetiny/output.c:	free(ctx->silencebuf);
squeezetiny/output.c:	buf_flush(ctx->outputbuf);
squeezetiny/output.c:	ctx->output.fade = FADE_INACTIVE;
squeezetiny/output.c:	if (ctx->output.state != OUTPUT_OFF) {
squeezetiny/output.c:		ctx->output.state = OUTPUT_STOPPED;
squeezetiny/output.c:		if (ctx->output.error_opening) {
squeezetiny/output.c:			ctx->output.current_sample_rate = ctx->output.default_sample_rate;
squeezetiny/output.c:		ctx->output.delay_active = false;
squeezetiny/output.c:	ctx->output.frames_played = ctx->output.frames_played_dmp = 0;
squeezetiny/output.c:	ctx->output.track_start_time = -1;
squeezetiny/stream.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
squeezetiny/stream.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
squeezetiny/stream.c:	if (!ctx->ssl) return recv(ctx->fd, buffer, bytes, options);
squeezetiny/stream.c:	n = SSL_read(ctx->ssl, (u8_t*) buffer, bytes);
squeezetiny/stream.c:	if (n <= 0 && SSL_get_error(ctx->ssl, n) == SSL_ERROR_ZERO_RETURN) return 0;
squeezetiny/stream.c:	if (!ctx->ssl) return send(ctx->fd, buffer, bytes, options);
squeezetiny/stream.c:		if ((n = SSL_write(ctx->ssl, (u8_t*) buffer, bytes)) >= 0) return n;
squeezetiny/stream.c:		err = SSL_get_error(ctx->ssl, n);
squeezetiny/stream.c:	if (!ctx->ssl) return poll(pollinfo, 1, timeout);
squeezetiny/stream.c:	if (pollinfo->events & POLLIN && SSL_pending(ctx->ssl)) {
squeezetiny/stream.c:#define _recv(ctx, buf, n, opt) recv(ctx->fd, buf, n, opt)
squeezetiny/stream.c:#define _send(ctx, buf, n, opt) send(ctx->fd, buf, n, opt)
squeezetiny/stream.c:	char *ptr = ctx->stream.header;
squeezetiny/stream.c:	int len = ctx->stream.header_len;
squeezetiny/stream.c:			ctx->stream.disconnect = LOCAL_DISCONNECT;
squeezetiny/stream.c:			ctx->stream.state = DISCONNECT;
squeezetiny/stream.c:	if (ctx->ssl) {
squeezetiny/stream.c:		SSL_shutdown(ctx->ssl);
squeezetiny/stream.c:		SSL_free(ctx->ssl);
squeezetiny/stream.c:		ctx->ssl = NULL;
squeezetiny/stream.c:	if (ctx->fd != -1) {
squeezetiny/stream.c:		closesocket(ctx->fd);
squeezetiny/stream.c:		ctx->fd = -1;
squeezetiny/stream.c:	ctx->stream.state = STOPPED;
squeezetiny/stream.c:	ctx->stream.state = state;
squeezetiny/stream.c:	ctx->stream.disconnect = disconnect;
squeezetiny/stream.c:	if (ctx->ssl) {
squeezetiny/stream.c:		SSL_shutdown(ctx->ssl);
squeezetiny/stream.c:		SSL_free(ctx->ssl);
squeezetiny/stream.c:		ctx->ssl = NULL;
squeezetiny/stream.c:	closesocket(ctx->fd);
squeezetiny/stream.c:	ctx->fd = -1;
squeezetiny/stream.c:	LOG_INFO("[%p] connecting to %s:%d", ctx, inet_ntoa(ctx->stream.addr.sin_addr), ntohs(ctx->stream.addr.sin_port));
squeezetiny/stream.c:	if (connect_timeout(sock, (struct sockaddr *) &ctx->stream.addr, sizeof(ctx->stream.addr), 10*1000) < 0) {
squeezetiny/stream.c:		ctx->ssl = SSL_new(SSLctx);
squeezetiny/stream.c:		SSL_set_fd(ctx->ssl, sock);
squeezetiny/stream.c:		if (*ctx->stream.host) SSL_set_tlsext_host_name(ctx->ssl, ctx->stream.host);
squeezetiny/stream.c:			status = SSL_connect(ctx->ssl);
squeezetiny/stream.c:				err = SSL_get_error(ctx->ssl, status);
squeezetiny/stream.c:			SSL_free(ctx->ssl);
squeezetiny/stream.c:			ctx->ssl = NULL;
squeezetiny/stream.c:	} else ctx->ssl = NULL;
squeezetiny/stream.c:	while (ctx->stream_running) {
squeezetiny/stream.c:		space = min(_buf_space(ctx->streambuf), _buf_cont_write(ctx->streambuf));
squeezetiny/stream.c:		if (ctx->fd < 0 || !space || ctx->stream.state <= STREAMING_WAIT) {
squeezetiny/stream.c:		if (ctx->stream.state == STREAMING_FILE) {
squeezetiny/stream.c:			int n = read(ctx->fd, ctx->streambuf->writep, space);
squeezetiny/stream.c:				_buf_inc_writep(ctx->streambuf, n);
squeezetiny/stream.c:				ctx->stream.bytes += n;
squeezetiny/stream.c:				LOG_SDEBUG("[%p] ctx->streambuf read %d bytes", ctx, n);
squeezetiny/stream.c:			pollinfo.fd = ctx->fd;
squeezetiny/stream.c:			if (ctx->stream.state == SEND_HEADERS) {
squeezetiny/stream.c:			if (ctx->fd < 0) {
squeezetiny/stream.c:			if ((pollinfo.revents & POLLOUT) && ctx->stream.state == SEND_HEADERS) {
squeezetiny/stream.c:				if (send_header(ctx)) ctx->stream.state = RECV_HEADERS;
squeezetiny/stream.c:				ctx->stream.header_mlen = ctx->stream.header_len;
squeezetiny/stream.c:				ctx->stream.header_len = 0;
squeezetiny/stream.c:				if (ctx->stream.state == RECV_HEADERS) {
squeezetiny/stream.c:						if (!ctx->ssl && !ctx->stream.header_len) {
squeezetiny/stream.c:							ctx->stream.header_len = ctx->stream.header_mlen;
squeezetiny/stream.c:							closesocket(ctx->fd);
squeezetiny/stream.c:							ctx->fd = -1;
squeezetiny/stream.c:								ctx->fd = sock;
squeezetiny/stream.c:								ctx->stream.state = SEND_HEADERS;
squeezetiny/stream.c:					*(ctx->stream.header + ctx->stream.header_len) = c;
squeezetiny/stream.c:					ctx->stream.header_len++;
squeezetiny/stream.c:					if (ctx->stream.header_len > MAX_HEADER - 1) {
squeezetiny/stream.c:						LOG_ERROR("[%p] received headers too long: %u", ctx, ctx->stream.header_len);
squeezetiny/stream.c:					if (ctx->stream.header_len > 1 && (c == '\r' || c == '\n')) {
squeezetiny/stream.c:						ctx->stream.endtok++;
squeezetiny/stream.c:						if (ctx->stream.endtok == 4) {
squeezetiny/stream.c:							*(ctx->stream.header + ctx->stream.header_len) = '\0';
squeezetiny/stream.c:							LOG_INFO("[%p] headers: len: %d\n%s", ctx, ctx->stream.header_len, ctx->stream.header);
squeezetiny/stream.c:							ctx->stream.state = ctx->stream.cont_wait ? STREAMING_WAIT : STREAMING_BUFFERING;
squeezetiny/stream.c:						ctx->stream.endtok = 0;
squeezetiny/stream.c:				if (ctx->stream.meta_interval && ctx->stream.meta_next == 0) {
squeezetiny/stream.c:					if (ctx->stream.meta_left == 0) {
squeezetiny/stream.c:						ctx->stream.meta_left = 16 * c;
squeezetiny/stream.c:						ctx->stream.header_len = 0; // amount of received meta data
squeezetiny/stream.c:					if (ctx->stream.meta_left) {
squeezetiny/stream.c:						int n = _recv(ctx, ctx->stream.header + ctx->stream.header_len, ctx->stream.meta_left, 0);
squeezetiny/stream.c:						ctx->stream.meta_left -= n;
squeezetiny/stream.c:						ctx->stream.header_len += n;
squeezetiny/stream.c:					if (ctx->stream.meta_left == 0) {
squeezetiny/stream.c:						if (ctx->stream.header_len) {
squeezetiny/stream.c:							*(ctx->stream.header + ctx->stream.header_len) = '\0';
squeezetiny/stream.c:							LOG_INFO("[%p] icy meta: len: %u\n%s", ctx, ctx->stream.header_len, ctx->stream.header);
squeezetiny/stream.c:							ctx->stream.meta_send = true;
squeezetiny/stream.c:						ctx->stream.meta_next = ctx->stream.meta_interval;
squeezetiny/stream.c:					space = min(_buf_space(ctx->streambuf), _buf_cont_write(ctx->streambuf));
squeezetiny/stream.c:					if (ctx->stream.meta_interval) {
squeezetiny/stream.c:						space = min(space, ctx->stream.meta_next);
squeezetiny/stream.c:					n = _recv(ctx, ctx->streambuf->writep, space, 0);
squeezetiny/stream.c:						LOG_INFO("[%p] end of stream (t:%lld)", ctx, ctx->stream.bytes);
squeezetiny/stream.c:						_buf_inc_writep(ctx->streambuf, n);
squeezetiny/stream.c:						ctx->stream.bytes += n;
squeezetiny/stream.c:						if (ctx->stream.meta_interval) {
squeezetiny/stream.c:							ctx->stream.meta_next -= n;
squeezetiny/stream.c:					if (ctx->stream.state == STREAMING_BUFFERING && ctx->stream.bytes > ctx->stream.threshold) {
squeezetiny/stream.c:						ctx->stream.state = STREAMING_HTTP;
squeezetiny/stream.c:	ctx->streambuf = &ctx->__s_buf;
squeezetiny/stream.c:	buf_init(ctx->streambuf, ((streambuf_size / (BYTES_PER_FRAME * 3)) * BYTES_PER_FRAME * 3));
squeezetiny/stream.c:	if (ctx->streambuf->buf == NULL) {
squeezetiny/stream.c:	ctx->ssl = NULL;
squeezetiny/stream.c:	ctx->stream_running = true;
squeezetiny/stream.c:	ctx->stream.state = STOPPED;
squeezetiny/stream.c:	ctx->stream.header = malloc(MAX_HEADER);
squeezetiny/stream.c:	*ctx->stream.header = '\0';
squeezetiny/stream.c:	ctx->fd = -1;
squeezetiny/stream.c:	touch_memory(ctx->streambuf->buf, ctx->streambuf->size);
squeezetiny/stream.c:	pthread_create(&ctx->stream_thread, &attr, (void *(*)(void*)) stream_thread, ctx);
squeezetiny/stream.c:	ctx->stream_running = false;
squeezetiny/stream.c:	pthread_join(ctx->stream_thread, NULL);
squeezetiny/stream.c:	free(ctx->stream.header);
squeezetiny/stream.c:	buf_destroy(ctx->streambuf);
squeezetiny/stream.c:	buf_flush(ctx->streambuf);
squeezetiny/stream.c:	ctx->stream.header_len = header_len;
squeezetiny/stream.c:	memcpy(ctx->stream.header, header, header_len);
squeezetiny/stream.c:	*(ctx->stream.header+header_len) = '\0';
squeezetiny/stream.c:	LOG_INFO("[%p] opening local file: %s", ctx, ctx->stream.header);
squeezetiny/stream.c:	ctx->fd = open(ctx->stream.header, O_RDONLY | O_BINARY);
squeezetiny/stream.c:	ctx->fd = open(ctx->stream.header, O_RDONLY);
squeezetiny/stream.c:	ctx->stream.state = STREAMING_FILE;
squeezetiny/stream.c:	if (ctx->fd < 0) {
squeezetiny/stream.c:		LOG_WARN("[%p] can't open file: %s", ctx, ctx->stream.header);
squeezetiny/stream.c:		ctx->stream.state = DISCONNECT;
squeezetiny/stream.c:	ctx->stream.cont_wait = false;
squeezetiny/stream.c:	ctx->stream.meta_interval = 0;
squeezetiny/stream.c:	ctx->stream.meta_next = 0;
squeezetiny/stream.c:	ctx->stream.meta_left = 0;
squeezetiny/stream.c:	ctx->stream.meta_send = false;
squeezetiny/stream.c:	ctx->stream.sent_headers = false;
squeezetiny/stream.c:	ctx->stream.bytes = 0;
squeezetiny/stream.c:	ctx->stream.threshold = threshold;
squeezetiny/stream.c:	memset(&ctx->stream.addr, 0, sizeof(ctx->stream.addr));
squeezetiny/stream.c:	ctx->stream.addr.sin_family = AF_INET;
squeezetiny/stream.c:	ctx->stream.addr.sin_addr.s_addr = ip;
squeezetiny/stream.c:	ctx->stream.addr.sin_port = port;
squeezetiny/stream.c:	*ctx->stream.host = '\0';
squeezetiny/stream.c:		sscanf(p, "Host:%255s", ctx->stream.host);
squeezetiny/stream.c:		if ((p = strchr(ctx->stream.host, ':')) != NULL) *p = '\0';
squeezetiny/stream.c:		ctx->stream.state = DISCONNECT;
squeezetiny/stream.c:		ctx->stream.disconnect = UNREACHABLE;
squeezetiny/stream.c:	buf_flush(ctx->streambuf);
squeezetiny/stream.c:	ctx->fd = sock;
squeezetiny/stream.c:	ctx->stream.state = SEND_HEADERS;
squeezetiny/stream.c:	ctx->stream.cont_wait = cont_wait;
squeezetiny/stream.c:	ctx->stream.meta_interval = 0;
squeezetiny/stream.c:	ctx->stream.meta_next = 0;
squeezetiny/stream.c:	ctx->stream.meta_left = 0;
squeezetiny/stream.c:	ctx->stream.meta_send = false;
squeezetiny/stream.c:	ctx->stream.header_len = header_len;
squeezetiny/stream.c:	memcpy(ctx->stream.header, header, header_len);
squeezetiny/stream.c:	*(ctx->stream.header+header_len) = '\0';
squeezetiny/stream.c:	LOG_INFO("[%p] header: %s", ctx, ctx->stream.header);
squeezetiny/stream.c:	ctx->stream.sent_headers = false;
squeezetiny/stream.c:	ctx->stream.bytes = 0;
squeezetiny/stream.c:	ctx->stream.threshold = threshold;
squeezetiny/mpg.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
squeezetiny/mpg.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
squeezetiny/mpg.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/mpg.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
squeezetiny/mpg.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/mpg.c:#define LOCK_O_not_direct   if (!ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
squeezetiny/mpg.c:#define UNLOCK_O_not_direct if (!ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/mpg.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
squeezetiny/mpg.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
squeezetiny/mpg.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
squeezetiny/mpg.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
squeezetiny/mpg.c:	bytes = min(_buf_used(ctx->streambuf), _buf_cont_read(ctx->streambuf));
squeezetiny/mpg.c:		space = min(_buf_space(ctx->outputbuf), _buf_cont_write(ctx->outputbuf));
squeezetiny/mpg.c:		write_buf = ctx->outputbuf->writep;
squeezetiny/mpg.c:		space = ctx->process.max_in_frames;
squeezetiny/mpg.c:		write_buf = ctx->process.inbuf;
squeezetiny/mpg.c:	if (ctx->decode.new_stream) {
squeezetiny/mpg.c:	ret = MPG123(&gm, decode, ctx->decode.handle, ctx->streambuf->readp, bytes, write_buf, space, &size);
squeezetiny/mpg.c:		if (ctx->decode.new_stream) {
squeezetiny/mpg.c:			MPG123(&gm, getformat, ctx->decode.handle, &rate, &channels, &enc);
squeezetiny/mpg.c:			ctx->output.current_sample_rate = decode_newstream(rate, ctx->output.supported_rates, ctx);
squeezetiny/mpg.c:			ctx->output.track_start = ctx->outputbuf->writep;
squeezetiny/mpg.c:			if (ctx->output.fade_mode) _checkfade(true, ctx);
squeezetiny/mpg.c:			ctx->decode.new_stream = false;
squeezetiny/mpg.c:	_buf_inc_readp(ctx->streambuf, bytes);
squeezetiny/mpg.c:		_buf_inc_writep(ctx->outputbuf, size);
squeezetiny/mpg.c:		ctx->process.in_frames = size / BYTES_PER_FRAME;
squeezetiny/mpg.c:	if (ret == MPG123_DONE || (bytes == 0 && size == 0 && ctx->stream.state <= DISCONNECT)) {
squeezetiny/mpg.c:	if (ctx->decode.handle) {
squeezetiny/mpg.c:		MPG123(&gm, delete, ctx->decode.handle);
squeezetiny/mpg.c:	ctx->decode.handle = MPG123(&gm, new, NULL, &err);
squeezetiny/mpg.c:	if (ctx->decode.handle == NULL) {
squeezetiny/mpg.c:	MPG123(&gm, format_none, ctx->decode.handle);
squeezetiny/mpg.c:	//MPG123(&m, param, ctx->decode.handle, MPG123_FORCE_RATE, 44100, 0);
squeezetiny/mpg.c:	//MPG123(&m, param, ctx->decode.handle, MPG123_REMOVE_FLAGS, MPG123_GAPLESS, 0);
squeezetiny/mpg.c:	MPG123(&gm, format, ctx->decode.handle, 44100, 2, MPG123_ENC_SIGNED_16);
squeezetiny/mpg.c:		MPG123(&m, format, ctx->decode.handle, list[i], 2, MPG123_ENC_SIGNED_16);
squeezetiny/mpg.c:	err = MPG123(&gm, open_feed, ctx->decode.handle);
squeezetiny/mpg.c:	MPG123(&gm, delete, ctx->decode.handle);
squeezetiny/mpg.c:	ctx->decode.handle = NULL;

./squeezetiny/faad.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
./squeezetiny/faad.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
./squeezetiny/faad.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/faad.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/faad.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/faad.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/faad.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
./squeezetiny/faad.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
./squeezetiny/faad.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/faad.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/faad.c:	struct faad *a = ctx->decode.handle;
./squeezetiny/faad.c:	size_t bytes = min(_buf_used(ctx->streambuf), _buf_cont_read(ctx->streambuf));
./squeezetiny/faad.c:		len = unpackN((u32_t *)ctx->streambuf->readp);
./squeezetiny/faad.c:		memcpy(type, ctx->streambuf->readp + 4, 4);
./squeezetiny/faad.c:			u8_t *ptr = ctx->streambuf->readp + 12;
./squeezetiny/faad.c:			u8_t *ptr = ctx->streambuf->readp + 12;
./squeezetiny/faad.c:			memcpy(a->stsc, ctx->streambuf->readp + 12, len - 12);
./squeezetiny/faad.c:			u8_t *ptr = ctx->streambuf->readp + 12;
./squeezetiny/faad.c:			_buf_inc_readp(ctx->streambuf, 8);
./squeezetiny/faad.c:						_buf_inc_readp(ctx->streambuf, skip);
./squeezetiny/faad.c:			u8_t *ptr = ctx->streambuf->readp + 8;
./squeezetiny/faad.c:			_buf_inc_readp(ctx->streambuf, consume);
./squeezetiny/faad.c:			_buf_inc_readp(ctx->streambuf, bytes);
./squeezetiny/faad.c:	struct faad *a = ctx->decode.handle;
./squeezetiny/faad.c:	bytes_total = _buf_used(ctx->streambuf);
./squeezetiny/faad.c:	bytes_wrap  = min(bytes_total, _buf_cont_read(ctx->streambuf));
./squeezetiny/faad.c:	if (ctx->stream.state <= DISCONNECT && !bytes_total) {
./squeezetiny/faad.c:		_buf_inc_readp(ctx->streambuf, consume);
./squeezetiny/faad.c:	if (ctx->decode.new_stream) {
./squeezetiny/faad.c:			while (bytes_wrap >= 2 && (*(ctx->streambuf->readp) != 0xFF || (*(ctx->streambuf->readp + 1) & 0xF6) != 0xF0)) {
./squeezetiny/faad.c:				_buf_inc_readp(ctx->streambuf, 1);
./squeezetiny/faad.c:				long n = NEAAC(&ga, Init, a->hAac, ctx->streambuf->readp, bytes_wrap, &a->samplerate, &a->channels);
./squeezetiny/faad.c:					_buf_inc_readp(ctx->streambuf, n);
./squeezetiny/faad.c:			bytes_total = _buf_used(ctx->streambuf);
./squeezetiny/faad.c:			bytes_wrap  = min(bytes_total, _buf_cont_read(ctx->streambuf));
./squeezetiny/faad.c:			ctx->output.current_sample_rate = decode_newstream(a->samplerate, ctx->output.supported_rates, ctx);
./squeezetiny/faad.c:			ctx->output.track_start = ctx->outputbuf->writep;
./squeezetiny/faad.c:			if (ctx->output.fade_mode) _checkfade(true, ctx);
./squeezetiny/faad.c:			ctx->decode.new_stream = false;
./squeezetiny/faad.c:		memcpy(buf, ctx->streambuf->readp, bytes_wrap);
./squeezetiny/faad.c:		memcpy(buf + bytes_wrap, ctx->streambuf->buf, WRAPBUF_LEN - bytes_wrap);
./squeezetiny/faad.c:		iptr = NEAAC(&ga, Decode, a->hAac, &info, ctx->streambuf->readp, bytes_wrap);
./squeezetiny/faad.c:				_buf_inc_readp(ctx->streambuf, skip);
./squeezetiny/faad.c:		_buf_inc_readp(ctx->streambuf, info.bytesconsumed);
./squeezetiny/faad.c:			f = _buf_cont_write(ctx->outputbuf) / BYTES_PER_FRAME;
./squeezetiny/faad.c:			optr = (s16_t *)ctx->outputbuf->writep;
./squeezetiny/faad.c:			f = ctx->process.max_in_frames;
./squeezetiny/faad.c:			optr = (s16_t *)ctx->process.inbuf;
./squeezetiny/faad.c:			_buf_inc_writep(ctx->outputbuf, f * BYTES_PER_FRAME);
./squeezetiny/faad.c:			ctx->process.in_frames = f;
./squeezetiny/faad.c:	struct faad *a = ctx->decode.handle;
./squeezetiny/faad.c:		a = ctx->decode.handle = malloc(sizeof(struct faad));
./squeezetiny/faad.c:	struct faad *a = ctx->decode.handle;
./squeezetiny/faad.c:	ctx->decode.handle = NULL;
./squeezetiny/output_raop.c:#define LOCK   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/output_raop.c:#define UNLOCK mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/output_raop.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
./squeezetiny/output_raop.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
./squeezetiny/output_raop.c:		if (ctx->output.fade == FADE_ACTIVE && ctx->output.fade_dir == FADE_CROSS && *cross_ptr) {
./squeezetiny/output_raop.c:			_apply_cross(ctx->outputbuf, out_frames, cross_gain_in, cross_gain_out, cross_ptr);
./squeezetiny/output_raop.c:		obuf = (s16_t*) ctx->outputbuf->readp;
./squeezetiny/output_raop.c:		obuf = (s16_t*) ctx->silencebuf;
./squeezetiny/output_raop.c:	_scale_frames((s16_t*) (ctx->output.buf + ctx->output.buf_frames * BYTES_PER_FRAME), obuf, out_frames, gainL, gainR);
./squeezetiny/output_raop.c:	ctx->output.buf_frames += out_frames;
./squeezetiny/output_raop.c:	free(ctx->output.buf);
./squeezetiny/output_raop.c:	while (ctx->output_running) {
./squeezetiny/output_raop.c:		if (ctx->output.state >= OUTPUT_BUFFER && raopcl_accept_frames(ctx->output.device) >= FRAMES_PER_BLOCK) {
./squeezetiny/output_raop.c:			if (ctx->output.buf_frames) {
./squeezetiny/output_raop.c:				raopcl_send_chunk(ctx->output.device, ctx->output.buf, ctx->output.buf_frames, &playtime);
./squeezetiny/output_raop.c:				if (ctx->output.detect_start_time) {
./squeezetiny/output_raop.c:					ctx->output.detect_start_time = false;
./squeezetiny/output_raop.c:					ctx->output.track_start_time = NTP2MS(playtime);
./squeezetiny/output_raop.c:					LOG_INFO("[%p]: track actual start time:%u (gap:%d)", ctx, ctx->output.track_start_time,
./squeezetiny/output_raop.c:										(s32_t) (ctx->output.track_start_time - ctx->output.start_at));
./squeezetiny/output_raop.c:				ctx->output.buf_frames = 0;
./squeezetiny/output_raop.c:		ctx->output.updated = gettime_ms();
./squeezetiny/output_raop.c:		ctx->output.device_frames = raopcl_queued_frames(ctx->output.device) + raopcl_latency(ctx->output.device);
./squeezetiny/output_raop.c:		ctx->output.device_true_frames = raopcl_queued_frames(ctx->output.device);
./squeezetiny/output_raop.c:		ctx->output.frames_played_dmp = ctx->output.frames_played;
./squeezetiny/output_raop.c:	memset(&ctx->output, 0, sizeof(ctx->output));
./squeezetiny/output_raop.c:	ctx->output.buf = malloc(FRAMES_PER_BLOCK * BYTES_PER_FRAME);
./squeezetiny/output_raop.c:	if (!ctx->output.buf) {
./squeezetiny/output_raop.c:	ctx->output_running = true;
./squeezetiny/output_raop.c:	ctx->output.buf_frames = 0;
./squeezetiny/output_raop.c:	ctx->output.start_frames = FRAMES_PER_BLOCK * 2;
./squeezetiny/output_raop.c:	ctx->output.write_cb = &_raop_write_frames;
./squeezetiny/output_raop.c:	pthread_create(&ctx->output_thread, &attr, (void *(*)(void*)) &output_raop_thread, ctx);
./squeezetiny/resample.c:	struct soxr *r = ctx->decode.process_handle;
./squeezetiny/resample.c:		SOXR(&gr, process, r->resampler, ctx->process.inbuf, ctx->process.in_frames, &idone, ctx->process.outbuf, ctx->process.max_out_frames, &odone);
./squeezetiny/resample.c:	if (idone != ctx->process.in_frames) {
./squeezetiny/resample.c:				  ctx, (unsigned)idone, ctx->process.in_frames, (unsigned)odone, ctx->process.max_out_frames);
./squeezetiny/resample.c:	ctx->process.out_frames = odone;
./squeezetiny/resample.c:	ctx->process.total_in  += idone;
./squeezetiny/resample.c:	ctx->process.total_out += odone;
./squeezetiny/resample.c:	struct soxr *r = ctx->decode.process_handle;
./squeezetiny/resample.c:	soxr_error_t error = SOXR(&gr, process, r->resampler, NULL, 0, NULL, ctx->process.outbuf, ctx->process.max_out_frames, &odone);
./squeezetiny/resample.c:	ctx->process.out_frames = odone;
./squeezetiny/resample.c:	ctx->process.total_out += odone;
./squeezetiny/resample.c:	struct soxr *r = ctx->decode.process_handle;
./squeezetiny/resample.c:	ctx->process.in_sample_rate = raw_sample_rate;
./squeezetiny/resample.c:	ctx->process.out_sample_rate = outrate;
./squeezetiny/resample.c:	struct soxr *r = ctx->decode.process_handle;
./squeezetiny/resample.c:	r = ctx->decode.process_handle = malloc(sizeof(struct soxr));
./squeezetiny/resample.c:	if (ctx->decode.process_handle) free(ctx->decode.process_handle);
./squeezetiny/mad.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
./squeezetiny/mad.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
./squeezetiny/mad.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/mad.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/mad.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/mad.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/mad.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
./squeezetiny/mad.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
./squeezetiny/mad.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/mad.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/mad.c:	u8_t *ptr = ctx->streambuf->readp;
./squeezetiny/mad.c:	u8_t *ptr = ctx->streambuf->readp;
./squeezetiny/mad.c:	struct mad *m = ctx->decode.handle;
./squeezetiny/mad.c:	struct mad *m = ctx->decode.handle;
./squeezetiny/mad.c:	bytes = min(_buf_used(ctx->streambuf), _buf_cont_read(ctx->streambuf));
./squeezetiny/mad.c:			_buf_inc_readp(ctx->streambuf, consume);
./squeezetiny/mad.c:			if (!ctx->stream.meta_interval) {
./squeezetiny/mad.c:	memcpy(m->readbuf + m->readbuf_len, ctx->streambuf->readp, bytes);
./squeezetiny/mad.c:	_buf_inc_readp(ctx->streambuf, bytes);
./squeezetiny/mad.c:	if (ctx->stream.state <= DISCONNECT && _buf_used(ctx->streambuf) == 0) {
./squeezetiny/mad.c:		if (ctx->decode.new_stream) {
./squeezetiny/mad.c:			//output.next_sample_rate = decode_newstream(m->synth.pcm.samplerate, ctx->output.supported_rates);
./squeezetiny/mad.c:			ctx->output.current_sample_rate = decode_newstream(m->synth.pcm.samplerate, ctx->output.supported_rates, ctx);
./squeezetiny/mad.c:			ctx->output.track_start = ctx->outputbuf->writep;
./squeezetiny/mad.c:			if (ctx->output.fade_mode) _checkfade(true, ctx);
./squeezetiny/mad.c:			ctx->decode.new_stream = false;
./squeezetiny/mad.c:			max_frames = _buf_space(ctx->outputbuf) / BYTES_PER_FRAME;
./squeezetiny/mad.c:			max_frames = ctx->process.max_in_frames - ctx->process.in_frames;
./squeezetiny/mad.c:				f = min(frames, _buf_cont_write(ctx->outputbuf) / BYTES_PER_FRAME);
./squeezetiny/mad.c:				optr = (s16_t *)ctx->outputbuf->writep;
./squeezetiny/mad.c:				f = min(frames, ctx->process.max_in_frames - ctx->process.in_frames);
./squeezetiny/mad.c:				optr = (s16_t *)((u8_t *) ctx->process.inbuf + ctx->process.in_frames * BYTES_PER_FRAME);
./squeezetiny/mad.c:				_buf_inc_writep(ctx->outputbuf, f * BYTES_PER_FRAME);
./squeezetiny/mad.c:				ctx->process.in_frames += f;
./squeezetiny/mad.c:	struct mad *m = ctx->decode.handle;
./squeezetiny/mad.c:		m = ctx->decode.handle = malloc(sizeof(struct mad));
./squeezetiny/mad.c:	struct mad *m = ctx->decode.handle;
./squeezetiny/mad.c:	ctx->decode.handle = NULL;
./squeezetiny/mpg.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
./squeezetiny/mpg.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
./squeezetiny/mpg.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/mpg.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/mpg.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/mpg.c:#define LOCK_O_not_direct   if (!ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/mpg.c:#define UNLOCK_O_not_direct if (!ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/mpg.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
./squeezetiny/mpg.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
./squeezetiny/mpg.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/mpg.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/mpg.c:	bytes = min(_buf_used(ctx->streambuf), _buf_cont_read(ctx->streambuf));
./squeezetiny/mpg.c:		space = min(_buf_space(ctx->outputbuf), _buf_cont_write(ctx->outputbuf));
./squeezetiny/mpg.c:		write_buf = ctx->outputbuf->writep;
./squeezetiny/mpg.c:		space = ctx->process.max_in_frames;
./squeezetiny/mpg.c:		write_buf = ctx->process.inbuf;
./squeezetiny/mpg.c:	if (ctx->decode.new_stream) {
./squeezetiny/mpg.c:	ret = MPG123(&gm, decode, ctx->decode.handle, ctx->streambuf->readp, bytes, write_buf, space, &size);
./squeezetiny/mpg.c:		if (ctx->decode.new_stream) {
./squeezetiny/mpg.c:			MPG123(&gm, getformat, ctx->decode.handle, &rate, &channels, &enc);
./squeezetiny/mpg.c:			ctx->output.current_sample_rate = decode_newstream(rate, ctx->output.supported_rates, ctx);
./squeezetiny/mpg.c:			ctx->output.track_start = ctx->outputbuf->writep;
./squeezetiny/mpg.c:			if (ctx->output.fade_mode) _checkfade(true, ctx);
./squeezetiny/mpg.c:			ctx->decode.new_stream = false;
./squeezetiny/mpg.c:	_buf_inc_readp(ctx->streambuf, bytes);
./squeezetiny/mpg.c:		_buf_inc_writep(ctx->outputbuf, size);
./squeezetiny/mpg.c:		ctx->process.in_frames = size / BYTES_PER_FRAME;
./squeezetiny/mpg.c:	if (ret == MPG123_DONE || (bytes == 0 && size == 0 && ctx->stream.state <= DISCONNECT)) {
./squeezetiny/mpg.c:	if (ctx->decode.handle) {
./squeezetiny/mpg.c:		MPG123(&gm, delete, ctx->decode.handle);
./squeezetiny/mpg.c:	ctx->decode.handle = MPG123(&gm, new, NULL, &err);
./squeezetiny/mpg.c:	if (ctx->decode.handle == NULL) {
./squeezetiny/mpg.c:	MPG123(&gm, format_none, ctx->decode.handle);
./squeezetiny/mpg.c:	//MPG123(&m, param, ctx->decode.handle, MPG123_FORCE_RATE, 44100, 0);
./squeezetiny/mpg.c:	//MPG123(&m, param, ctx->decode.handle, MPG123_REMOVE_FLAGS, MPG123_GAPLESS, 0);
./squeezetiny/mpg.c:	MPG123(&gm, format, ctx->decode.handle, 44100, 2, MPG123_ENC_SIGNED_16);
./squeezetiny/mpg.c:		MPG123(&m, format, ctx->decode.handle, list[i], 2, MPG123_ENC_SIGNED_16);
./squeezetiny/mpg.c:	err = MPG123(&gm, open_feed, ctx->decode.handle);
./squeezetiny/mpg.c:	MPG123(&gm, delete, ctx->decode.handle);
./squeezetiny/mpg.c:	ctx->decode.handle = NULL;
./squeezetiny/slimproto.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
./squeezetiny/slimproto.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
./squeezetiny/slimproto.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/slimproto.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/slimproto.c:#define LOCK_D   mutex_lock(ctx->decode.mutex)
./squeezetiny/slimproto.c:#define UNLOCK_D mutex_unlock(ctx->decode.mutex)
./squeezetiny/slimproto.c:#define LOCK_P   mutex_lock(ctx->mutex)
./squeezetiny/slimproto.c:#define UNLOCK_P mutex_unlock(ctx->mutex)
./squeezetiny/slimproto.c:	if (ctx->callback) rc = ctx->callback(ctx->self, ctx->MR, action, param);
./squeezetiny/slimproto.c:	packN(&pkt.bytes_received_H, (u64_t)ctx->status.stream_bytes >> 32);
./squeezetiny/slimproto.c:	packN(&pkt.bytes_received_L, (u64_t)ctx->status.stream_bytes & 0xffffffff);
./squeezetiny/slimproto.c:	send_packet((u8_t *)&pkt, sizeof(pkt), ctx->sock);
./squeezetiny/slimproto.c:	send_packet((u8_t *)base_cap, strlen(base_cap), ctx->sock);
./squeezetiny/slimproto.c:	send_packet((u8_t *)fixed_cap, strlen(fixed_cap), ctx->sock);
./squeezetiny/slimproto.c:	send_packet((u8_t *)var_cap, strlen(var_cap), ctx->sock);
./squeezetiny/slimproto.c:	if (ctx->status.frames_played > ctx->status.device_frames) {
./squeezetiny/slimproto.c:		ms_played = (u32_t)(((u64_t)(ctx->status.frames_played - ctx->status.device_frames) * (u64_t)1000) / (u64_t)ctx->status.current_sample_rate);
./squeezetiny/slimproto.c:		if (now > ctx->status.updated) ms_played += (now - ctx->status.updated);
./squeezetiny/slimproto.c:		LOG_DEBUG("[%p]: ms fr:%u clk:%u (frames_played: %u device_frames: %u)", ctx, ms_played, now - ctx->output.start_at, ctx->status.frames_played, ctx->status.device_frames);
./squeezetiny/slimproto.c:	} else if (ctx->status.frames_played && now > ctx->status.stream_start) {
./squeezetiny/slimproto.c:		ms_played = now - ctx->status.stream_start;
./squeezetiny/slimproto.c:		LOG_INFO("[%p]: ms_played: %u using elapsed time (frames_played: %u device_frames: %u)", ctx, ms_played, ctx->status.frames_played, ctx->status.device_frames);
./squeezetiny/slimproto.c:	packN(&pkt.stream_buffer_fullness, ctx->status.stream_full);
./squeezetiny/slimproto.c:	packN(&pkt.stream_buffer_size, ctx->status.stream_size);
./squeezetiny/slimproto.c:	packN(&pkt.bytes_received_H, (u64_t)ctx->status.stream_bytes >> 32);
./squeezetiny/slimproto.c:	packN(&pkt.bytes_received_L, (u64_t)ctx->status.stream_bytes & 0xffffffff);
./squeezetiny/slimproto.c:	packN(&pkt.output_buffer_size, ctx->status.output_size);
./squeezetiny/slimproto.c:	packN(&pkt.output_buffer_fullness, ctx->status.output_full);
./squeezetiny/slimproto.c:				   ctx, (u32_t) ctx->status.stream_bytes, ctx->status.stream_full, ctx->status.output_full, ms_played, now - ctx->status.stream_start,
./squeezetiny/slimproto.c:				   ms_played - now + ctx->status.stream_start, now - ctx->status.updated);
./squeezetiny/slimproto.c:	send_packet((u8_t *)&pkt, sizeof(pkt), ctx->sock);
./squeezetiny/slimproto.c:		ctx->status.frames_played = 0;
./squeezetiny/slimproto.c:		buf_flush(ctx->streambuf);
./squeezetiny/slimproto.c:		ctx->status.frames_played = 0;
./squeezetiny/slimproto.c:		buf_flush(ctx->streambuf);
./squeezetiny/slimproto.c:		if (ctx->last_command != 'q') ctx_callback(ctx, SQ_STOP, NULL);
./squeezetiny/slimproto.c:			ctx->output.pause_frames = interval * ctx->status.current_sample_rate / 1000;
./squeezetiny/slimproto.c:			ctx->output.state = interval ? OUTPUT_PAUSE_FRAMES : OUTPUT_STOPPED;
./squeezetiny/slimproto.c:			ctx->output.skip_frames = interval * ctx->status.current_sample_rate / 1000;
./squeezetiny/slimproto.c:			ctx->output.state = OUTPUT_SKIP_FRAMES;
./squeezetiny/slimproto.c:			ctx->output.state = OUTPUT_RUNNING;
./squeezetiny/slimproto.c:			ctx->output.start_at = jiffies;
./squeezetiny/slimproto.c:			if (ip == 0) ip = ctx->slimproto_ip;
./squeezetiny/slimproto.c:			ctx->autostart = strm->autostart - '0';
./squeezetiny/slimproto.c:			if (format.sample_rate > ctx->config.sample_rate) {
./squeezetiny/slimproto.c:				 LOG_WARN("[%p]: Sample rate %u error suspected, forcing to %u", ctx, format.sample_rate, ctx->config.sample_rate);
./squeezetiny/slimproto.c:				 format.sample_rate = ctx->config.sample_rate;
./squeezetiny/slimproto.c:			} else if (ctx->autostart >= 2) {
./squeezetiny/slimproto.c:			stream_sock(ip, port, header, header_len, strm->threshold * 1024, ctx->autostart >= 2, ctx);
./squeezetiny/slimproto.c:			ctx->sentSTMu = ctx->sentSTMo = ctx->sentSTMl = ctx->sentSTMd = false;
./squeezetiny/slimproto.c:			ctx->output.threshold = strm->output_threshold;
./squeezetiny/slimproto.c:			ctx->output.next_replay_gain = unpackN(&strm->replay_gain);
./squeezetiny/slimproto.c:			ctx->output.fade_mode = strm->transition_type - '0';
./squeezetiny/slimproto.c:			ctx->output.fade_secs = strm->transition_period;
./squeezetiny/slimproto.c:			LOG_DEBUG("[%p]: set fade mode: %u", ctx, ctx->output.fade_mode);
./squeezetiny/slimproto.c:	ctx->last_command = strm->command;
./squeezetiny/slimproto.c:	if (ctx->autostart > 1) {
./squeezetiny/slimproto.c:		ctx->autostart -= 2;
./squeezetiny/slimproto.c:		if (ctx->stream.state == STREAMING_WAIT) {
./squeezetiny/slimproto.c:			ctx->stream.state = STREAMING_BUFFERING;
./squeezetiny/slimproto.c:			ctx->stream.meta_interval = ctx->stream.meta_next = cont->metaint;
./squeezetiny/slimproto.c:	ctx->on = (aude->enable_spdif) ? true : false;
./squeezetiny/slimproto.c:	LOG_DEBUG("[%p] on/off using aude %d", ctx, ctx->on);
./squeezetiny/slimproto.c:	ctx_callback(ctx, SQ_ONOFF, &ctx->on);
./squeezetiny/slimproto.c:	ctx->output.gainL = ctx->output.gainR = FIXED_ONE;
./squeezetiny/slimproto.c:			if (strlen(ctx->config.name)) {
./squeezetiny/slimproto.c:				sendSETDName(ctx->config.name, ctx->sock);
./squeezetiny/slimproto.c:			strncpy(ctx->config.name, setd->data, SQ_STR_LENGTH);
./squeezetiny/slimproto.c:			ctx->config.name[SQ_STR_LENGTH - 1] = '\0';
./squeezetiny/slimproto.c:			sendSETDName(setd->data, ctx->sock);
./squeezetiny/slimproto.c:			ctx_callback(ctx, SQ_SETNAME, (void*) ctx->config.name);
./squeezetiny/slimproto.c:	ctx->new_server = serv->server_ip;
./squeezetiny/slimproto.c:		if (!ctx->new_server_cap) {
./squeezetiny/slimproto.c:			ctx->new_server_cap = malloc(SYNC_CAP_LEN + 10 + 1);
./squeezetiny/slimproto.c:		ctx->new_server_cap[0] = '\0';
./squeezetiny/slimproto.c:		strcat(ctx->new_server_cap, SYNC_CAP);
./squeezetiny/slimproto.c:		strncat(ctx->new_server_cap, (const char *)(pkt + sizeof(struct serv_packet)), 10);
./squeezetiny/slimproto.c:		if (ctx->new_server_cap) {
./squeezetiny/slimproto.c:			free(ctx->new_server_cap);
./squeezetiny/slimproto.c:			ctx->new_server_cap = NULL;
./squeezetiny/slimproto.c:	ctx_callback(ctx, SQ_SETSERVER, (void*) &ctx->new_server);
./squeezetiny/slimproto.c:	set_readwake_handles(ehandles, ctx->sock, ctx->wake_e);
./squeezetiny/slimproto.c:	while (ctx->running && !ctx->new_server) {
./squeezetiny/slimproto.c:					int n = recv(ctx->sock, ctx->slim_run.buffer + got, expect, 0);
./squeezetiny/slimproto.c:						process(ctx->slim_run.buffer, got, ctx);
./squeezetiny/slimproto.c:					int n = recv(ctx->sock, ctx->slim_run.buffer + got, 2 - got, 0);
./squeezetiny/slimproto.c:						expect = ctx->slim_run.buffer[0] << 8 | ctx->slim_run.buffer[1]; // length pack 'n'
./squeezetiny/slimproto.c:			if (ctx->cli_sock > 0 && gettime_ms() > ctx->cli_timestamp + 10000) {
./squeezetiny/slimproto.c:				if (!mutex_trylock(ctx->cli_mutex)) {
./squeezetiny/slimproto.c:					LOG_INFO("[%p] Closing CLI socket %d", ctx, ctx->cli_sock);
./squeezetiny/slimproto.c:					closesocket(ctx->cli_sock);
./squeezetiny/slimproto.c:					ctx->cli_sock = -1;
./squeezetiny/slimproto.c:					mutex_unlock(ctx->cli_mutex);
./squeezetiny/slimproto.c:		if (wake || now - ctx->slim_run.last > 100 || ctx->slim_run.last > now) {
./squeezetiny/slimproto.c:			ctx->slim_run.last = now;
./squeezetiny/slimproto.c:			ctx->status.stream_full = _buf_used(ctx->streambuf);
./squeezetiny/slimproto.c:			ctx->status.stream_size = ctx->streambuf->size;
./squeezetiny/slimproto.c:			ctx->status.stream_bytes = ctx->stream.bytes;
./squeezetiny/slimproto.c:			ctx->status.stream_state = ctx->stream.state;
./squeezetiny/slimproto.c:			if (ctx->stream.state == DISCONNECT) {
./squeezetiny/slimproto.c:				disconnect_code = ctx->stream.disconnect;
./squeezetiny/slimproto.c:				ctx->stream.state = STOPPED;
./squeezetiny/slimproto.c:			if (!ctx->stream.sent_headers &&
./squeezetiny/slimproto.c:				(ctx->stream.state == STREAMING_HTTP || ctx->stream.state == STREAMING_WAIT || ctx->stream.state == STREAMING_BUFFERING)) {
./squeezetiny/slimproto.c:				header_len = ctx->stream.header_len;
./squeezetiny/slimproto.c:				memcpy(ctx->slim_run.header, ctx->stream.header, header_len);
./squeezetiny/slimproto.c:				ctx->stream.sent_headers = true;
./squeezetiny/slimproto.c:			if (ctx->stream.meta_send) {
./squeezetiny/slimproto.c:				header_len = ctx->stream.header_len;
./squeezetiny/slimproto.c:				memcpy(ctx->slim_run.header, ctx->stream.header, header_len);
./squeezetiny/slimproto.c:				ctx->stream.meta_send = false;
./squeezetiny/slimproto.c:			ctx->status.output_full = min(_buf_used(ctx->outputbuf) + ctx->output.device_true_frames * BYTES_PER_FRAME, ctx->outputbuf->size);
./squeezetiny/slimproto.c:			ctx->status.output_size = ctx->outputbuf->size;
./squeezetiny/slimproto.c:			ctx->status.frames_played = ctx->output.frames_played_dmp;
./squeezetiny/slimproto.c:			ctx->status.current_sample_rate = ctx->output.current_sample_rate;
./squeezetiny/slimproto.c:			ctx->status.updated = ctx->output.updated;
./squeezetiny/slimproto.c:			ctx->status.device_frames = ctx->output.device_frames;
./squeezetiny/slimproto.c:			if (ctx->output.track_started) {
./squeezetiny/slimproto.c:				ctx->output.track_started = false;
./squeezetiny/slimproto.c:				ctx->status.stream_start = ctx->output.track_start_time;
./squeezetiny/slimproto.c:				ctx_callback(ctx, SQ_STARTED, &ctx->output.track_start_time);
./squeezetiny/slimproto.c:			if (ctx->output.state == OUTPUT_RUNNING && !ctx->sentSTMu && ctx->status.output_full == 0 && ctx->status.stream_state <= DISCONNECT) {
./squeezetiny/slimproto.c:				ctx->sentSTMu = true;
./squeezetiny/slimproto.c:			if (ctx->output.state == OUTPUT_RUNNING && !ctx->sentSTMo && ctx->status.output_full == 0 && ctx->status.stream_state == STREAMING_HTTP) {
./squeezetiny/slimproto.c:				ctx->sentSTMo = true;
./squeezetiny/slimproto.c:			if (ctx->decode.state == DECODE_RUNNING && now - ctx->status.last > 1000) {
./squeezetiny/slimproto.c:				ctx->status.last = now;
./squeezetiny/slimproto.c:			if ((ctx->status.stream_state == STREAMING_HTTP || ctx->status.stream_state == STREAMING_FILE || ctx->stream.disconnect == DISCONNECT_OK)
./squeezetiny/slimproto.c:				&& !ctx->sentSTMl && ctx->decode.state == DECODE_READY) {
./squeezetiny/slimproto.c:				if (ctx->autostart == 0) {
./squeezetiny/slimproto.c:					ctx->decode.state = DECODE_RUNNING;
./squeezetiny/slimproto.c:					ctx->sentSTMl = true;
./squeezetiny/slimproto.c:				} else if (ctx->autostart == 1) {
./squeezetiny/slimproto.c:					ctx->decode.state = DECODE_RUNNING;
./squeezetiny/slimproto.c:					if (ctx->output.state == OUTPUT_STOPPED) {
./squeezetiny/slimproto.c:						ctx->output.state = OUTPUT_BUFFER;
./squeezetiny/slimproto.c:			if (ctx->decode.state == DECODE_COMPLETE || ctx->decode.state == DECODE_ERROR) {
./squeezetiny/slimproto.c:				if (ctx->decode.state == DECODE_COMPLETE) _sendSTMd = true;
./squeezetiny/slimproto.c:				if (ctx->decode.state == DECODE_ERROR)    _sendSTMn = true;
./squeezetiny/slimproto.c:				ctx->decode.state = DECODE_STOPPED;
./squeezetiny/slimproto.c:				if (ctx->status.stream_state == STREAMING_HTTP || ctx->status.stream_state == STREAMING_FILE) {
./squeezetiny/slimproto.c:			if (_sendDSCO) sendDSCO(disconnect_code, ctx->sock);
./squeezetiny/slimproto.c:			if (_sendRESP) sendRESP(ctx->slim_run.header, header_len, ctx->sock);
./squeezetiny/slimproto.c:			if (_sendMETA) sendMETA(ctx->slim_run.header, header_len, ctx->sock);
./squeezetiny/slimproto.c:	wake_signal(ctx->wake_e);
./squeezetiny/slimproto.c:	if (!ctx->slimproto_ip) d.sin_addr.s_addr = htonl(INADDR_BROADCAST);
./squeezetiny/slimproto.c:	else d.sin_addr.s_addr = ctx->slimproto_ip;
./squeezetiny/slimproto.c:				strncpy(ctx->server_version, p + 1, min(SERVER_VERSION_LEN, *p));
./squeezetiny/slimproto.c:				ctx->server_version[min(SERVER_VERSION_LEN, *p)] = '\0';
./squeezetiny/slimproto.c:				strncpy(ctx->server_port, p + 1, min(5, *p));
./squeezetiny/slimproto.c:				ctx->server_port[min(6, *p)] = '\0';
./squeezetiny/slimproto.c:			strcpy(ctx->server_ip, inet_ntoa(s.sin_addr));
./squeezetiny/slimproto.c:	} while (s.sin_addr.s_addr == 0 && ctx->running);
./squeezetiny/slimproto.c:	ctx->slimproto_ip =  s.sin_addr.s_addr;
./squeezetiny/slimproto.c:	ctx->slimproto_port = ntohs(s.sin_port);
./squeezetiny/slimproto.c:	ctx->serv_addr.sin_port = s.sin_port;
./squeezetiny/slimproto.c:	ctx->serv_addr.sin_addr.s_addr = s.sin_addr.s_addr;
./squeezetiny/slimproto.c:	ctx->serv_addr.sin_family = AF_INET;
./squeezetiny/slimproto.c:	mutex_create(ctx->mutex);
./squeezetiny/slimproto.c:	mutex_create(ctx->cli_mutex);
./squeezetiny/slimproto.c:	while (ctx->running) {
./squeezetiny/slimproto.c:		if (ctx->new_server) {
./squeezetiny/slimproto.c:			ctx->slimproto_ip = ctx->new_server;
./squeezetiny/slimproto.c:			ctx->new_server = 0;
./squeezetiny/slimproto.c:			LOG_INFO("[%p] switching server to %s:%d", ctx, inet_ntoa(ctx->serv_addr.sin_addr), ntohs(ctx->serv_addr.sin_port));
./squeezetiny/slimproto.c:		ctx->cli_sock = -1;
./squeezetiny/slimproto.c:		ctx->sock = socket(AF_INET, SOCK_STREAM, 0);
./squeezetiny/slimproto.c:		set_nonblock(ctx->sock);
./squeezetiny/slimproto.c:		set_nosigpipe(ctx->sock);
./squeezetiny/slimproto.c:		LOG_INFO("[%p] server %s:%d", ctx, inet_ntoa(ctx->serv_addr.sin_addr), ntohs(ctx->serv_addr.sin_port));
./squeezetiny/slimproto.c:		if (connect_timeout(ctx->sock, (struct sockaddr *) &ctx->serv_addr, sizeof(ctx->serv_addr), 5) != 0) {
./squeezetiny/slimproto.c:			if (!strcmp(ctx->config.server, "?") && ++failed_connect > 5) {
./squeezetiny/slimproto.c:				ctx->slimproto_ip = 0;
./squeezetiny/slimproto.c:			ctx->var_cap[0] = '\0';
./squeezetiny/slimproto.c:			if (ctx->new_server_cap) {
./squeezetiny/slimproto.c:				strcat(ctx->var_cap, ctx->new_server_cap);
./squeezetiny/slimproto.c:				free(ctx->new_server_cap);
./squeezetiny/slimproto.c:				ctx->new_server_cap = NULL;
./squeezetiny/slimproto.c:			sendHELO(reconnect, ctx->fixed_cap, ctx->var_cap, ctx->mac, ctx);
./squeezetiny/slimproto.c:		closesocket(ctx->sock);
./squeezetiny/slimproto.c:		if (ctx->cli_sock != -1) closesocket(ctx->cli_sock);
./squeezetiny/slimproto.c:		if (ctx->new_server_cap)	{
./squeezetiny/slimproto.c:			free(ctx->new_server_cap);
./squeezetiny/slimproto.c:			ctx->new_server_cap = NULL;
./squeezetiny/slimproto.c:	mutex_destroy(ctx->mutex);
./squeezetiny/slimproto.c:	mutex_destroy(ctx->cli_mutex);
./squeezetiny/slimproto.c:	LOG_INFO("[%p] slimproto stop for %s", ctx, ctx->config.name);
./squeezetiny/slimproto.c:  	ctx->running = false;
./squeezetiny/slimproto.c:	pthread_detach(ctx->thread);
./squeezetiny/slimproto.c:	wake_create(ctx->wake_e);
./squeezetiny/slimproto.c:	ctx->running = true;
./squeezetiny/slimproto.c:	ctx->slimproto_ip = 0;
./squeezetiny/slimproto.c:	ctx->slimproto_port = PORT;
./squeezetiny/slimproto.c:	ctx->sock = -1;
./squeezetiny/slimproto.c:	if (strcmp(ctx->config.server, "?")) {
./squeezetiny/slimproto.c:		server_addr(ctx->config.server, &ctx->slimproto_ip, &ctx->slimproto_port);
./squeezetiny/slimproto.c:	strcpy(ctx->var_cap, "");
./squeezetiny/slimproto.c:	ctx->new_server_cap = NULL;
./squeezetiny/slimproto.c:	sprintf(ctx->fixed_cap, ",MaxSampleRate=%u", ctx->config.sample_rate);
./squeezetiny/slimproto.c:	codec = buf = strdup(ctx->config.codecs);
./squeezetiny/slimproto.c:				strcat(ctx->fixed_cap, ",");
./squeezetiny/slimproto.c:				strcat(ctx->fixed_cap, codec);
./squeezetiny/slimproto.c:	memcpy(ctx->mac, ctx->config.mac, 6);
./squeezetiny/slimproto.c:	LOG_INFO("[%p] connecting to %s:%d", ctx, inet_ntoa(ctx->serv_addr.sin_addr), ntohs(ctx->serv_addr.sin_port));
./squeezetiny/slimproto.c:	ctx->new_server = 0;
./squeezetiny/slimproto.c:	pthread_create(&ctx->thread, &attr, (void *(*)(void*)) slimproto, ctx);
./squeezetiny/flac.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
./squeezetiny/flac.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
./squeezetiny/flac.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/flac.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/flac.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/flac.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/flac.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
./squeezetiny/flac.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
./squeezetiny/flac.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/flac.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/flac.c:	bytes = min(_buf_used(ctx->streambuf), _buf_cont_read(ctx->streambuf));
./squeezetiny/flac.c:	end = (ctx->stream.state <= DISCONNECT && bytes == 0);
./squeezetiny/flac.c:	memcpy(buffer, ctx->streambuf->readp, bytes);
./squeezetiny/flac.c:	_buf_inc_readp(ctx->streambuf, bytes);
./squeezetiny/flac.c:	if (ctx->decode.new_stream) {
./squeezetiny/flac.c:		ctx->output.track_start = ctx->outputbuf->writep;
./squeezetiny/flac.c:		ctx->decode.new_stream = false;
./squeezetiny/flac.c:		ctx->output.current_sample_rate = decode_newstream(frame->header.sample_rate, ctx->output.supported_rates, ctx);
./squeezetiny/flac.c:		if (ctx->output.fade_mode) _checkfade(true, ctx);
./squeezetiny/flac.c:			optr = (s16_t *)ctx->outputbuf->writep;
./squeezetiny/flac.c:			f = min(_buf_space(ctx->outputbuf), _buf_cont_write(ctx->outputbuf)) / BYTES_PER_FRAME;
./squeezetiny/flac.c:			optr = (s16_t *)ctx->process.inbuf;
./squeezetiny/flac.c:			f = ctx->process.max_in_frames;
./squeezetiny/flac.c:			_buf_inc_writep(ctx->outputbuf, f * BYTES_PER_FRAME);
./squeezetiny/flac.c:			ctx->process.in_frames = f;
./squeezetiny/flac.c:	struct flac *f = ctx->decode.handle;
./squeezetiny/flac.c:		f = ctx->decode.handle = malloc(sizeof(struct flac));
./squeezetiny/flac.c:	struct flac *f = ctx->decode.handle;
./squeezetiny/flac.c:	free(ctx->decode.handle);
./squeezetiny/flac.c:	ctx->decode.handle = NULL;
./squeezetiny/flac.c:	struct flac *f = ctx->decode.handle;
./squeezetiny/pcm.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
./squeezetiny/pcm.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
./squeezetiny/pcm.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/pcm.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/pcm.c:#define LOCK_O_direct   if (ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/pcm.c:#define UNLOCK_O_direct if (ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/pcm.c:#define LOCK_O_not_direct   if (!ctx->decode.direct) mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/pcm.c:#define UNLOCK_O_not_direct if (!ctx->decode.direct) mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/pcm.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
./squeezetiny/pcm.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
./squeezetiny/pcm.c:#define LOCK_O_direct   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/pcm.c:#define UNLOCK_O_direct mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/pcm.c:	struct pcm *p = ctx->decode.handle;
./squeezetiny/pcm.c:	iptr = (u8_t *)ctx->streambuf->readp;
./squeezetiny/pcm.c:	if (ctx->decode.new_stream && p->big_endian && !(*((u64_t*) iptr)) &&
./squeezetiny/pcm.c:		   (strstr(ctx->server_version, "7.7") || strstr(ctx->server_version, "7.8"))) {
./squeezetiny/pcm.c:		_buf_inc_readp(ctx->streambuf, 8);
./squeezetiny/pcm.c:	bytes = min(_buf_used(ctx->streambuf), _buf_cont_read(ctx->streambuf));
./squeezetiny/pcm.c:	if (ctx->stream.state <= DISCONNECT && bytes == 0) {
./squeezetiny/pcm.c:		out = min(_buf_space(ctx->outputbuf), _buf_cont_write(ctx->outputbuf)) / BYTES_PER_FRAME;
./squeezetiny/pcm.c:		optr = ctx->outputbuf->writep;
./squeezetiny/pcm.c:		out = ctx->process.max_in_frames;
./squeezetiny/pcm.c:		optr = ctx->process.inbuf;
./squeezetiny/pcm.c:	if (ctx->decode.new_stream) {
./squeezetiny/pcm.c:		ctx->output.current_sample_rate = decode_newstream(p->sample_rate, ctx->output.supported_rates, ctx);
./squeezetiny/pcm.c:		ctx->output.track_start = ctx->outputbuf->writep;
./squeezetiny/pcm.c:		if (ctx->output.fade_mode) _checkfade(true, ctx);
./squeezetiny/pcm.c:		ctx->decode.new_stream = false;
./squeezetiny/pcm.c:			out = ctx->process.max_in_frames;
./squeezetiny/pcm.c:	if (in == 0 && bytes > 0 && _buf_used(ctx->streambuf) >= bytes_per_frame) {
./squeezetiny/pcm.c:		memcpy(buf + bytes, ctx->streambuf->buf, bytes_per_frame - bytes);
./squeezetiny/pcm.c:	_buf_inc_readp(ctx->streambuf, frames * bytes_per_frame);
./squeezetiny/pcm.c:		_buf_inc_writep(ctx->outputbuf, frames * BYTES_PER_FRAME);
./squeezetiny/pcm.c:		ctx->process.in_frames = frames;
./squeezetiny/pcm.c:	struct pcm *p = ctx->decode.handle;
./squeezetiny/pcm.c:	if (!p)	p = ctx->decode.handle = malloc(sizeof(struct pcm));
./squeezetiny/pcm.c:	if (ctx->decode.handle) free(ctx->decode.handle);
./squeezetiny/pcm.c:	ctx->decode.handle = NULL;
./squeezetiny/main.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
./squeezetiny/main.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
./squeezetiny/main.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/main.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/main.c:#define LOCK_D   mutex_lock(ctx->decode.mutex)
./squeezetiny/main.c:#define UNLOCK_D mutex_unlock(ctx->decode.mutex)
./squeezetiny/main.c:#define LOCK_P   mutex_lock(ctx->mutex)
./squeezetiny/main.c:#define UNLOCK_P mutex_unlock(ctx->mutex)
./squeezetiny/main.c:	ctx->callback = NULL;
./squeezetiny/main.c:	ctx->in_use = false;
./squeezetiny/main.c:	if (ctx->cli_sock > 0) return true;
./squeezetiny/main.c:	ctx->cli_sock = socket(AF_INET, SOCK_STREAM, 0);
./squeezetiny/main.c:	set_nonblock(ctx->cli_sock);
./squeezetiny/main.c:	set_nosigpipe(ctx->cli_sock);
./squeezetiny/main.c:	addr.sin_addr.s_addr = ctx->slimproto_ip;
./squeezetiny/main.c:	if (connect(ctx->cli_sock, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
./squeezetiny/main.c:			ctx->cli_sock = -1;
./squeezetiny/main.c:	LOG_INFO("[%p]: opened CLI socket %d", ctx, ctx->cli_sock);
./squeezetiny/main.c:	mutex_lock(ctx->cli_mutex);
./squeezetiny/main.c:		mutex_unlock(ctx->cli_mutex);
./squeezetiny/main.c:	ctx->cli_timestamp = gettime_ms();
./squeezetiny/main.c:	send_packet((u8_t*) packet, len, ctx->cli_sock);
./squeezetiny/main.c:		k = recv(ctx->cli_sock, packet + len, CLI_LEN-1 - len, 0);
./squeezetiny/main.c:	mutex_unlock(ctx->cli_mutex);
./squeezetiny/main.c:	if (!handle || !ctx->in_use) {
./squeezetiny/main.c:	sprintf(cmd, "%s mode", ctx->cli_id);
./squeezetiny/main.c:	if (!handle || !ctx->in_use) {
./squeezetiny/main.c:	sprintf(cmd, "%s playlist index", ctx->cli_id);
./squeezetiny/main.c:		sprintf(cmd, "%s playlist tracks", ctx->cli_id);
./squeezetiny/main.c:	sprintf(cmd, "%s playlist remote %d", ctx->cli_id, idx);
./squeezetiny/main.c:	sprintf(cmd, "%s playlist path %d", ctx->cli_id, idx);
./squeezetiny/main.c:		sprintf(cmd, "%s songinfo 0 10 url:%s tags:cfldatgrK", ctx->cli_id, metadata->path);
./squeezetiny/main.c:				snprintf(metadata->artwork, SQ_STR_LENGTH, "http://%s:%s/music/%s/cover.jpg", ctx->server_ip, ctx->server_port, p);
./squeezetiny/main.c:		sprintf(cmd, "%s playlist title %d", ctx->cli_id, idx);
./squeezetiny/main.c:		sprintf(cmd, "%s playlist album %d", ctx->cli_id, idx);
./squeezetiny/main.c:		sprintf(cmd, "%s playlist artist %d", ctx->cli_id, idx);
./squeezetiny/main.c:		sprintf(cmd, "%s playlist genre %d", ctx->cli_id, idx);
./squeezetiny/main.c:		sprintf(cmd, "%s status %d 1 tags:K", ctx->cli_id, idx);
./squeezetiny/main.c:		sprintf(cmd, "%s playlist duration %d", ctx->cli_id, idx);
./squeezetiny/main.c:		snprintf(artwork, SQ_STR_LENGTH, "http://%s:%s%s", ctx->server_ip, ctx->server_port, metadata->artwork);
./squeezetiny/main.c:	if (!handle || !ctx->in_use) {
./squeezetiny/main.c:	sprintf(cmd, "%s time", ctx->cli_id);
./squeezetiny/main.c:	if (!ctx->running || !ctx->on || !handle || !ctx->in_use) return;
./squeezetiny/main.c:			sprintf(cmd, "%s pause", ctx->cli_id);
./squeezetiny/main.c:			sprintf(cmd, "%s play", ctx->cli_id);
./squeezetiny/main.c:			sprintf(cmd, "%s mode", ctx->cli_id);
./squeezetiny/main.c:				sprintf(cmd, "%s pause %d", ctx->cli_id, strstr(rsp, "pause") ? 0 : 1);
./squeezetiny/main.c:				sprintf(cmd, "%s pause", ctx->cli_id);
./squeezetiny/main.c:			sprintf(cmd, "%s stop", ctx->cli_id);
./squeezetiny/main.c:			if (strstr(param, "up")) sprintf(cmd, "%s mixer volume +5", ctx->cli_id);
./squeezetiny/main.c:			else if (strstr(param, "down")) sprintf(cmd, "%s mixer volume +5", ctx->cli_id);
./squeezetiny/main.c:				 else sprintf(cmd, "%s mixer volume %s", ctx->cli_id, (char*) param);
./squeezetiny/main.c:			sprintf(cmd, "%s mixer muting toggle", ctx->cli_id);
./squeezetiny/main.c:			sprintf(cmd, "%s playlist index -1", ctx->cli_id);
./squeezetiny/main.c:			sprintf(cmd, "%s playlist index +1", ctx->cli_id);
./squeezetiny/main.c:			sprintf(cmd, "%s playlist shuffle 1", ctx->cli_id);
./squeezetiny/main.c:			sprintf(cmd, "%s time %+d", ctx->cli_id, *((s16_t*) param));
./squeezetiny/main.c:	ctx->self = ctx_i + 1;
./squeezetiny/main.c:	ctx->on = false;
./squeezetiny/main.c:	ctx->callback = callback;
./squeezetiny/main.c:	ctx->MR = MR;
./squeezetiny/main.c:	memcpy(&ctx->config, param, sizeof(sq_dev_param_t));
./squeezetiny/main.c:	sprintf(ctx->cli_id, "%02x:%02x:%02x:%02x:%02x:%02x",
./squeezetiny/main.c:										  ctx->config.mac[0], ctx->config.mac[1], ctx->config.mac[2],
./squeezetiny/main.c:										  ctx->config.mac[3], ctx->config.mac[4], ctx->config.mac[5]);
./squeezetiny/main.c:	stream_thread_init(ctx->config.stream_buf_size, ctx);
./squeezetiny/main.c:	output_hue_thread_init(hue, ctx->config.output_buf_size, ctx);
./squeezetiny/decode.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
./squeezetiny/decode.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
./squeezetiny/decode.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/decode.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/decode.c:#define LOCK_D   mutex_lock(ctx->decode.mutex);
./squeezetiny/decode.c:#define UNLOCK_D mutex_unlock(ctx->decode.mutex);
./squeezetiny/decode.c:#define IF_DIRECT(x)    if (ctx->decode.direct) { x }
./squeezetiny/decode.c:#define IF_PROCESS(x)   if (!ctx->decode.direct) { x }
./squeezetiny/decode.c:	while (ctx->decode_running) {
./squeezetiny/decode.c:		bytes = _buf_used(ctx->streambuf);
./squeezetiny/decode.c:		toend = (ctx->stream.state <= DISCONNECT);
./squeezetiny/decode.c:		space = _buf_space(ctx->outputbuf);
./squeezetiny/decode.c:		if (ctx->decode.state == DECODE_RUNNING && ctx->codec) {
./squeezetiny/decode.c:				min_space = ctx->codec->min_space;
./squeezetiny/decode.c:				min_space = ctx->process.max_out_frames * BYTES_PER_FRAME;
./squeezetiny/decode.c:			if (space > min_space && (bytes > ctx->codec->min_read_bytes || toend)) {
./squeezetiny/decode.c:				ctx->decode.state = ctx->codec->decode(ctx);
./squeezetiny/decode.c:					if (ctx->process.in_frames) {
./squeezetiny/decode.c:					if (ctx->decode.state == DECODE_COMPLETE) {
./squeezetiny/decode.c:				if (ctx->decode.state != DECODE_RUNNING) {
./squeezetiny/decode.c:					LOG_INFO("decode %s", ctx->decode.state == DECODE_COMPLETE ? "complete" : "error");
./squeezetiny/decode.c:					if (ctx->output.fade_mode) _checkfade(false, ctx);
./squeezetiny/decode.c:	mutex_create(ctx->decode.mutex);
./squeezetiny/decode.c:	ctx->decode_running = true;
./squeezetiny/decode.c:	ctx->decode.new_stream = true;
./squeezetiny/decode.c:	ctx->decode.state = DECODE_STOPPED;
./squeezetiny/decode.c:	ctx->decode.handle = NULL;
./squeezetiny/decode.c:	ctx->decode.process_handle = NULL;
./squeezetiny/decode.c:		ctx->decode.direct = true;
./squeezetiny/decode.c:		ctx->decode.process = false;
./squeezetiny/decode.c:	pthread_create(&ctx->decode_thread, &attr, (void *(*)(void*)) decode_thread, ctx);
./squeezetiny/decode.c:	if (ctx->codec) {
./squeezetiny/decode.c:		ctx->codec->close(ctx);
./squeezetiny/decode.c:		ctx->codec = NULL;
./squeezetiny/decode.c:	ctx->decode_running = false;
./squeezetiny/decode.c:	pthread_join(ctx->decode_thread, NULL);
./squeezetiny/decode.c:	mutex_destroy(ctx->decode.mutex);
./squeezetiny/decode.c:	ctx->decode.state = DECODE_STOPPED;
./squeezetiny/decode.c:		if (ctx->decode.process) {
./squeezetiny/decode.c:			sample_rate = process_newstream(&ctx->decode.direct, sample_rate, supported_rates, ctx);
./squeezetiny/decode.c:	ctx->decode.new_stream = true;
./squeezetiny/decode.c:	ctx->decode.state = DECODE_STOPPED;
./squeezetiny/decode.c:		ctx->decode.direct = true; // potentially changed within codec when processing enabled
./squeezetiny/decode.c:			if (ctx->codec && ctx->codec != codecs[i]) {
./squeezetiny/decode.c:				LOG_DEBUG("closing codec: '%c'", ctx->codec->id);
./squeezetiny/decode.c:				ctx->codec->close(ctx);
./squeezetiny/decode.c:			ctx->codec = codecs[i];
./squeezetiny/decode.c:			ctx->codec->open(sample_size, sample_rate, channels, endianness, ctx);
./squeezetiny/decode.c:			ctx->decode.state = DECODE_READY;
./squeezetiny/process.c:#define LOCK_D   mutex_lock(ctx->decode.mutex);
./squeezetiny/process.c:#define UNLOCK_D mutex_unlock(ctx->decode.mutex);
./squeezetiny/process.c:#define LOCK_O   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/process.c:#define UNLOCK_O mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/process.c:	size_t frames = ctx->process.out_frames;
./squeezetiny/process.c:	u16_t *iptr   = (u16_t *) ctx->process.outbuf;
./squeezetiny/process.c:		frames_t f = min(_buf_space(ctx->outputbuf), _buf_cont_write(ctx->outputbuf)) / BYTES_PER_FRAME;
./squeezetiny/process.c:		u16_t *optr = (u16_t *)ctx->outputbuf->writep;
./squeezetiny/process.c:			_buf_inc_writep(ctx->outputbuf, f * BYTES_PER_FRAME);
./squeezetiny/process.c:	ctx->process.in_frames = 0;
./squeezetiny/process.c:	LOG_DEBUG("[%p]: processing track complete - frames in: %lu out: %lu", ctx, ctx->process.total_in, ctx->process.total_out);
./squeezetiny/process.c:		ctx->process.in_frames = ctx->process.out_frames = 0;
./squeezetiny/process.c:		ctx->process.total_in = ctx->process.total_out = 0;
./squeezetiny/process.c:		max_in_frames = ctx->codec->min_space / BYTES_PER_FRAME ;
./squeezetiny/process.c:		if (ctx->process.out_sample_rate % ctx->process.in_sample_rate == 0) {
./squeezetiny/process.c:			max_out_frames = max_in_frames * (ctx->process.out_sample_rate / ctx->process.in_sample_rate);
./squeezetiny/process.c:			max_out_frames = (int)(1.1 * (float)max_in_frames * (float)ctx->process.out_sample_rate / (float)ctx->process.in_sample_rate);
./squeezetiny/process.c:		if (ctx->process.max_in_frames != max_in_frames) {
./squeezetiny/process.c:			if (ctx->process.inbuf) free(ctx->process.inbuf);
./squeezetiny/process.c:			ctx->process.inbuf = malloc(max_in_frames * BYTES_PER_FRAME);
./squeezetiny/process.c:			ctx->process.max_in_frames = max_in_frames;
./squeezetiny/process.c:		if (ctx->process.max_out_frames != max_out_frames) {
./squeezetiny/process.c:			if (ctx->process.outbuf) free(ctx->process.outbuf);
./squeezetiny/process.c:			ctx->process.outbuf = malloc(max_out_frames * BYTES_PER_FRAME);
./squeezetiny/process.c:			ctx->process.max_out_frames = max_out_frames;
./squeezetiny/process.c:		if (!ctx->process.inbuf || !ctx->process.outbuf) {
./squeezetiny/process.c:		return ctx->process.out_sample_rate;
./squeezetiny/process.c:	ctx->process.in_frames = 0;
./squeezetiny/process.c:	memset(&ctx->process, 0, sizeof(ctx->process));
./squeezetiny/process.c:		ctx->decode.process = true;
./squeezetiny/process.c:	ctx->decode.process = false;
./squeezetiny/process.c:	if (ctx->process.inbuf) free(ctx->process.inbuf);
./squeezetiny/process.c:	if (ctx->process.outbuf) free(ctx->process.outbuf);
./squeezetiny/output_hue.c:#define LOCK   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/output_hue.c:#define UNLOCK mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/output_hue.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
./squeezetiny/output_hue.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
./squeezetiny/output_hue.c:		if (ctx->output.fade == FADE_ACTIVE && ctx->output.fade_dir == FADE_CROSS && *cross_ptr) {
./squeezetiny/output_hue.c:			_apply_cross(ctx->outputbuf, out_frames, cross_gain_in, cross_gain_out, cross_ptr);
./squeezetiny/output_hue.c:		obuf = (s16_t*) ctx->outputbuf->readp;
./squeezetiny/output_hue.c:		obuf = (s16_t*) ctx->silencebuf;
./squeezetiny/output_hue.c:	_scale_frames((s16_t*) (ctx->output.buf + ctx->output.buf_frames * BYTES_PER_FRAME), obuf, out_frames, gainL, gainR);
./squeezetiny/output_hue.c:	ctx->output.buf_frames += out_frames;
./squeezetiny/output_hue.c:	free(ctx->output.buf);
./squeezetiny/output_hue.c:	while (ctx->output_running) {
./squeezetiny/output_hue.c:		if (ctx->output.state >= OUTPUT_BUFFER) {
./squeezetiny/output_hue.c:			if (ctx->output.buf_frames) {
./squeezetiny/output_hue.c:                LOG_INFO("[%p]: sending chunk to %s", ctx->output.device, ((hue_bridge_t *)ctx->output.device)->name);
./squeezetiny/output_hue.c:                disco_send_chunk(ctx->output.device, ctx->output.buf, ctx->output.buf_frames);
./squeezetiny/output_hue.c:				if (ctx->output.detect_start_time) {
./squeezetiny/output_hue.c:					ctx->output.detect_start_time = false;
./squeezetiny/output_hue.c:					ctx->output.track_start_time = gettime_ms();
./squeezetiny/output_hue.c:					LOG_INFO("[%p]: track actual start time:%u (gap:%d)", ctx, ctx->output.track_start_time,
./squeezetiny/output_hue.c:										(s32_t) (ctx->output.track_start_time - ctx->output.start_at));
./squeezetiny/output_hue.c:				ctx->output.buf_frames = 0;
./squeezetiny/output_hue.c:		ctx->output.updated = gettime_ms();
./squeezetiny/output_hue.c:		ctx->output.device_frames = 0;
./squeezetiny/output_hue.c:		ctx->output.device_true_frames = 0;
./squeezetiny/output_hue.c:		ctx->output.frames_played_dmp = ctx->output.frames_played;
./squeezetiny/output_hue.c:	memset(&ctx->output, 0, sizeof(ctx->output));
./squeezetiny/output_hue.c:	ctx->output.buf = malloc(FRAMES_PER_BLOCK * BYTES_PER_FRAME);
./squeezetiny/output_hue.c:	if (!ctx->output.buf) {
./squeezetiny/output_hue.c:	ctx->output_running = true;
./squeezetiny/output_hue.c:	ctx->output.buf_frames = 0;
./squeezetiny/output_hue.c:	ctx->output.start_frames = FRAMES_PER_BLOCK * 2;
./squeezetiny/output_hue.c:	ctx->output.write_cb = &_hue_write_frames;
./squeezetiny/output_hue.c:	pthread_create(&ctx->output_thread, &attr, (void *(*)(void*)) &output_hue_thread, ctx);
./squeezetiny/output.c:#define LOCK   mutex_lock(ctx->outputbuf->mutex)
./squeezetiny/output.c:#define UNLOCK mutex_unlock(ctx->outputbuf->mutex)
./squeezetiny/output.c:	s32_t gainL = ctx->output.current_replay_gain ? gain32(ctx->output.gainL, ctx->output.current_replay_gain) : ctx->output.gainL;
./squeezetiny/output.c:	s32_t gainR = ctx->output.current_replay_gain ? gain32(ctx->output.gainR, ctx->output.current_replay_gain) : ctx->output.gainR;
./squeezetiny/output.c:	frames = _buf_used(ctx->outputbuf) / BYTES_PER_FRAME;
./squeezetiny/output.c:	if (ctx->output.state == OUTPUT_BUFFER && frames > ctx->output.threshold * ctx->output.current_sample_rate / 100 && frames > ctx->output.start_frames) {
./squeezetiny/output.c:		ctx->output.state = OUTPUT_RUNNING;
./squeezetiny/output.c:	if (ctx->output.state == OUTPUT_SKIP_FRAMES) {
./squeezetiny/output.c:			frames_t skip = min(frames, ctx->output.skip_frames);
./squeezetiny/output.c:			LOG_INFO("[%p]: skip %u of %u frames", ctx, skip, ctx->output.skip_frames);
./squeezetiny/output.c:			ctx->output.frames_played += skip;
./squeezetiny/output.c:				frames_t cont_frames = min(skip, _buf_cont_read(ctx->outputbuf) / BYTES_PER_FRAME);
./squeezetiny/output.c:				_buf_inc_readp(ctx->outputbuf, cont_frames * BYTES_PER_FRAME);
./squeezetiny/output.c:		ctx->output.state = OUTPUT_RUNNING;
./squeezetiny/output.c:	if (ctx->output.state == OUTPUT_PAUSE_FRAMES) {
./squeezetiny/output.c:		LOG_INFO("[%p]: pause %u frames", ctx, ctx->output.pause_frames);
./squeezetiny/output.c:		if (ctx->output.pause_frames == 0) {
./squeezetiny/output.c:			ctx->output.state = OUTPUT_RUNNING;
./squeezetiny/output.c:			frames = min(avail, ctx->output.pause_frames);
./squeezetiny/output.c:			ctx->output.pause_frames -= frames;
./squeezetiny/output.c:		frames_t cont_frames = _buf_cont_read(ctx->outputbuf) / BYTES_PER_FRAME;
./squeezetiny/output.c:		if (ctx->output.track_start && !silence) {
./squeezetiny/output.c:			if (ctx->output.track_start == ctx->outputbuf->readp) {
./squeezetiny/output.c:				LOG_INFO("[%p]: track start sample rate: %u replay_gain: %u", ctx, ctx->output.current_sample_rate, ctx->output.next_replay_gain);
./squeezetiny/output.c:				ctx->output.frames_played = 0;
./squeezetiny/output.c:				ctx->output.track_started = true;
./squeezetiny/output.c:				ctx->output.detect_start_time = true;
./squeezetiny/output.c:				if (!(ctx->output.fade == FADE_ACTIVE) || !(ctx->output.fade_mode == FADE_CROSSFADE)) {
./squeezetiny/output.c:					ctx->output.current_replay_gain = ctx->output.next_replay_gain;
./squeezetiny/output.c:				ctx->output.track_start = NULL;
./squeezetiny/output.c:			} else if (ctx->output.track_start > ctx->outputbuf->readp) {
./squeezetiny/output.c:				cont_frames = min(cont_frames, (ctx->output.track_start - ctx->outputbuf->readp) / BYTES_PER_FRAME);
./squeezetiny/output.c:		if (ctx->output.fade && !silence) {
./squeezetiny/output.c:			if (ctx->output.fade == FADE_DUE) {
./squeezetiny/output.c:				if (ctx->output.fade_start == ctx->outputbuf->readp) {
./squeezetiny/output.c:					ctx->output.fade = FADE_ACTIVE;
./squeezetiny/output.c:				} else if (ctx->output.fade_start > ctx->outputbuf->readp) {
./squeezetiny/output.c:					cont_frames = min(cont_frames, (ctx->output.fade_start - ctx->outputbuf->readp) / BYTES_PER_FRAME);
./squeezetiny/output.c:			if (ctx->output.fade == FADE_ACTIVE) {
./squeezetiny/output.c:				frames_t cur_f = ctx->outputbuf->readp >= ctx->output.fade_start ? (ctx->outputbuf->readp - ctx->output.fade_start) / BYTES_PER_FRAME :
./squeezetiny/output.c:					(ctx->outputbuf->readp + ctx->outputbuf->size - ctx->output.fade_start) / BYTES_PER_FRAME;
./squeezetiny/output.c:				frames_t dur_f = ctx->output.fade_end >= ctx->output.fade_start ? (ctx->output.fade_end - ctx->output.fade_start) / BYTES_PER_FRAME :
./squeezetiny/output.c:					(ctx->output.fade_end + ctx->outputbuf->size - ctx->output.fade_start) / BYTES_PER_FRAME;
./squeezetiny/output.c:					if (ctx->output.fade_mode == FADE_INOUT && ctx->output.fade_dir == FADE_DOWN) {
./squeezetiny/output.c:						ctx->output.fade_dir = FADE_UP;
./squeezetiny/output.c:						ctx->output.fade_start = ctx->outputbuf->readp;
./squeezetiny/output.c:						ctx->output.fade_end = ctx->outputbuf->readp + dur_f * BYTES_PER_FRAME;
./squeezetiny/output.c:						if (ctx->output.fade_end >= ctx->outputbuf->wrap) {
./squeezetiny/output.c:							ctx->output.fade_end -= ctx->outputbuf->size;
./squeezetiny/output.c:					} else if (ctx->output.fade_mode == FADE_CROSSFADE) {
./squeezetiny/output.c:						if (_buf_used(ctx->outputbuf) >= dur_f * BYTES_PER_FRAME) {
./squeezetiny/output.c:							_buf_inc_readp(ctx->outputbuf, dur_f * BYTES_PER_FRAME);
./squeezetiny/output.c:						ctx->output.fade = FADE_INACTIVE;
./squeezetiny/output.c:						ctx->output.current_replay_gain = ctx->output.next_replay_gain;
./squeezetiny/output.c:						ctx->output.fade = FADE_INACTIVE;
./squeezetiny/output.c:				if (ctx->output.fade) {
./squeezetiny/output.c:					if (ctx->output.fade_end > ctx->outputbuf->readp) {
./squeezetiny/output.c:						cont_frames = min(cont_frames, (ctx->output.fade_end - ctx->outputbuf->readp) / BYTES_PER_FRAME);
./squeezetiny/output.c:					if (ctx->output.fade_dir == FADE_UP || ctx->output.fade_dir == FADE_DOWN) {
./squeezetiny/output.c:						if (ctx->output.fade_dir == FADE_DOWN) {
./squeezetiny/output.c:					if (ctx->output.fade_dir == FADE_CROSS) {
./squeezetiny/output.c:						if (_buf_used(ctx->outputbuf) / BYTES_PER_FRAME > dur_f + size) {
./squeezetiny/output.c:							if (ctx->output.current_replay_gain) {
./squeezetiny/output.c:								cross_gain_out = gain32(cross_gain_out, ctx->output.current_replay_gain);
./squeezetiny/output.c:							if (ctx->output.next_replay_gain) {
./squeezetiny/output.c:								cross_gain_in = gain32(cross_gain_in, ctx->output.next_replay_gain);
./squeezetiny/output.c:							gainL = ctx->output.gainL;
./squeezetiny/output.c:							gainR = ctx->output.gainR;
./squeezetiny/output.c:							cross_ptr = (s16_t *)(ctx->output.fade_end + cur_f * BYTES_PER_FRAME);
./squeezetiny/output.c:							ctx->output.fade = FADE_INACTIVE;
./squeezetiny/output.c:		wrote = ctx->output.write_cb(ctx, out_frames, silence, gainL, gainR, cross_gain_in, cross_gain_out, &cross_ptr);
./squeezetiny/output.c:			_buf_inc_readp(ctx->outputbuf, out_frames * BYTES_PER_FRAME);
./squeezetiny/output.c:			ctx->output.frames_played += out_frames;
./squeezetiny/output.c:	LOG_INFO("[%p]: fade mode: %u duration: %u %s", ctx, ctx->output.fade_mode, ctx->output.fade_secs, start ? "track-start" : "track-end");
./squeezetiny/output.c:	bytes = ctx->output.current_sample_rate * BYTES_PER_FRAME * ctx->output.fade_secs;
./squeezetiny/output.c:	if (ctx->output.fade_mode == FADE_INOUT) {
./squeezetiny/output.c:	if (start && (ctx->output.fade_mode == FADE_IN || (ctx->output.fade_mode == FADE_INOUT && _buf_used(ctx->outputbuf) == 0))) {
./squeezetiny/output.c:		bytes = min(bytes, ctx->outputbuf->size - BYTES_PER_FRAME); // shorter than full buffer otherwise start and end align
./squeezetiny/output.c:		ctx->output.fade = FADE_DUE;
./squeezetiny/output.c:		ctx->output.fade_dir = FADE_UP;
./squeezetiny/output.c:		ctx->output.fade_start = ctx->outputbuf->writep;
./squeezetiny/output.c:		ctx->output.fade_end = ctx->output.fade_start + bytes;
./squeezetiny/output.c:		if (ctx->output.fade_end >= ctx->outputbuf->wrap) {
./squeezetiny/output.c:			ctx->output.fade_end -= ctx->outputbuf->size;
./squeezetiny/output.c:	if (!start && (ctx->output.fade_mode == FADE_OUT || ctx->output.fade_mode == FADE_INOUT)) {
./squeezetiny/output.c:		bytes = min(_buf_used(ctx->outputbuf), bytes);
./squeezetiny/output.c:		LOG_INFO("[%p]: fade %s: %u frames", ctx, ctx->output.fade_mode == FADE_INOUT ? "IN-OUT" : "OUT", bytes / BYTES_PER_FRAME);
./squeezetiny/output.c:		ctx->output.fade = FADE_DUE;
./squeezetiny/output.c:		ctx->output.fade_dir = FADE_DOWN;
./squeezetiny/output.c:		ctx->output.fade_start = ctx->outputbuf->writep - bytes;
./squeezetiny/output.c:		if (ctx->output.fade_start < ctx->outputbuf->buf) {
./squeezetiny/output.c:			ctx->output.fade_start += ctx->outputbuf->size;
./squeezetiny/output.c:		ctx->output.fade_end = ctx->outputbuf->writep;
./squeezetiny/output.c:	if (start && ctx->output.fade_mode == FADE_CROSSFADE) {
./squeezetiny/output.c:		if (_buf_used(ctx->outputbuf) != 0) {
./squeezetiny/output.c:			bytes = min(bytes, _buf_used(ctx->outputbuf));               // max of current remaining samples from previous track
./squeezetiny/output.c:			bytes = min(bytes, (frames_t)(ctx->outputbuf->size * 0.9));  // max of 90% of outputbuf as we consume additional buffer during crossfade
./squeezetiny/output.c:			ctx->output.fade = FADE_DUE;
./squeezetiny/output.c:			ctx->output.fade_dir = FADE_CROSS;
./squeezetiny/output.c:			ctx->output.fade_start = ctx->outputbuf->writep - bytes;
./squeezetiny/output.c:			if (ctx->output.fade_start < ctx->outputbuf->buf) {
./squeezetiny/output.c:				ctx->output.fade_start += ctx->outputbuf->size;
./squeezetiny/output.c:			ctx->output.fade_end = ctx->outputbuf->writep;
./squeezetiny/output.c:			ctx->output.track_start = ctx->output.fade_start;
./squeezetiny/output.c:		else if (ctx->outputbuf->size == OUTPUTBUF_SIZE && ctx->outputbuf->readp == ctx->outputbuf->buf) {
./squeezetiny/output.c:			_buf_resize(ctx->outputbuf, OUTPUTBUF_SIZE_CROSSFADE);
./squeezetiny/output.c:			touch_memory(ctx->outputbuf->buf, ctx->outputbuf->size);
./squeezetiny/output.c:	ctx->outputbuf = &ctx->__o_buf;
./squeezetiny/output.c:	buf_init(ctx->outputbuf, outputbuf_size);
./squeezetiny/output.c:	if (!ctx->outputbuf->buf) {
./squeezetiny/output.c:	ctx->silencebuf = malloc(MAX_SILENCE_FRAMES * BYTES_PER_FRAME);
./squeezetiny/output.c:	if (!ctx->silencebuf) {
./squeezetiny/output.c:	memset(ctx->silencebuf, 0, MAX_SILENCE_FRAMES * BYTES_PER_FRAME);
./squeezetiny/output.c:	ctx->output.state = OUTPUT_STOPPED;
./squeezetiny/output.c:	ctx->output.fade = FADE_INACTIVE;
./squeezetiny/output.c:    ctx->output.device = device;
./squeezetiny/output.c:	ctx->output.error_opening = false;
./squeezetiny/output.c:	ctx->output.detect_start_time = false;
./squeezetiny/output.c:	ctx->output.current_sample_rate = ctx->output.default_sample_rate = sample_rate;
./squeezetiny/output.c:	ctx->output.supported_rates[0] = sample_rate;
./squeezetiny/output.c:	ctx->output.supported_rates[1] = 0;
./squeezetiny/output.c:	ctx->output_running = false;
./squeezetiny/output.c:	pthread_join(ctx->output_thread, NULL);
./squeezetiny/output.c:	buf_destroy(ctx->outputbuf);
./squeezetiny/output.c:	free(ctx->silencebuf);
./squeezetiny/output.c:	buf_flush(ctx->outputbuf);
./squeezetiny/output.c:	ctx->output.fade = FADE_INACTIVE;
./squeezetiny/output.c:	if (ctx->output.state != OUTPUT_OFF) {
./squeezetiny/output.c:		ctx->output.state = OUTPUT_STOPPED;
./squeezetiny/output.c:		if (ctx->output.error_opening) {
./squeezetiny/output.c:			ctx->output.current_sample_rate = ctx->output.default_sample_rate;
./squeezetiny/output.c:		ctx->output.delay_active = false;
./squeezetiny/output.c:	ctx->output.frames_played = 0;
./squeezetiny/stream.c:#define LOCK_S   mutex_lock(ctx->streambuf->mutex)
./squeezetiny/stream.c:#define UNLOCK_S mutex_unlock(ctx->streambuf->mutex)
./squeezetiny/stream.c:	char *ptr = ctx->stream.header;
./squeezetiny/stream.c:	int len = ctx->stream.header_len;
./squeezetiny/stream.c:		n = send(ctx->fd, ptr, len, MSG_NOSIGNAL);
./squeezetiny/stream.c:			ctx->stream.disconnect = LOCAL_DISCONNECT;
./squeezetiny/stream.c:			ctx->stream.state = DISCONNECT;
./squeezetiny/stream.c:	if (ctx->fd != -1) {
./squeezetiny/stream.c:		closesocket(ctx->fd);
./squeezetiny/stream.c:		ctx->fd = -1;
./squeezetiny/stream.c:	ctx->stream.state = STOPPED;
./squeezetiny/stream.c:	ctx->stream.state = state;
./squeezetiny/stream.c:	ctx->stream.disconnect = disconnect;
./squeezetiny/stream.c:	closesocket(ctx->fd);
./squeezetiny/stream.c:	ctx->fd = -1;
./squeezetiny/stream.c:	while (ctx->stream_running) {
./squeezetiny/stream.c:		space = min(_buf_space(ctx->streambuf), _buf_cont_write(ctx->streambuf));
./squeezetiny/stream.c:		if (ctx->fd < 0 || !space || ctx->stream.state <= STREAMING_WAIT) {
./squeezetiny/stream.c:		if (ctx->stream.state == STREAMING_FILE) {
./squeezetiny/stream.c:			int n = read(ctx->fd, ctx->streambuf->writep, space);
./squeezetiny/stream.c:				_buf_inc_writep(ctx->streambuf, n);
./squeezetiny/stream.c:				ctx->stream.bytes += n;
./squeezetiny/stream.c:				LOG_SDEBUG("[%p] ctx->streambuf read %d bytes", ctx, n);
./squeezetiny/stream.c:			pollinfo.fd = ctx->fd;
./squeezetiny/stream.c:			if (ctx->stream.state == SEND_HEADERS) {
./squeezetiny/stream.c:			if (ctx->fd < 0) {
./squeezetiny/stream.c:			if ((pollinfo.revents & POLLOUT) && ctx->stream.state == SEND_HEADERS) {
./squeezetiny/stream.c:				ctx->stream.header_len = 0;
./squeezetiny/stream.c:				ctx->stream.state = RECV_HEADERS;
./squeezetiny/stream.c:				if (ctx->stream.state == RECV_HEADERS) {
./squeezetiny/stream.c:					int n = recv(ctx->fd, &c, 1, 0);
./squeezetiny/stream.c:					*(ctx->stream.header + ctx->stream.header_len) = c;
./squeezetiny/stream.c:					ctx->stream.header_len++;
./squeezetiny/stream.c:					if (ctx->stream.header_len > MAX_HEADER - 1) {
./squeezetiny/stream.c:						LOG_ERROR("[%p] received headers too long: %u", ctx, ctx->stream.header_len);
./squeezetiny/stream.c:					if (ctx->stream.header_len > 1 && (c == '\r' || c == '\n')) {
./squeezetiny/stream.c:						ctx->stream.endtok++;
./squeezetiny/stream.c:						if (ctx->stream.endtok == 4) {
./squeezetiny/stream.c:							*(ctx->stream.header + ctx->stream.header_len) = '\0';
./squeezetiny/stream.c:							LOG_INFO("[%p] headers: len: %d\n%s", ctx, ctx->stream.header_len, ctx->stream.header);
./squeezetiny/stream.c:							ctx->stream.state = ctx->stream.cont_wait ? STREAMING_WAIT : STREAMING_BUFFERING;
./squeezetiny/stream.c:						ctx->stream.endtok = 0;
./squeezetiny/stream.c:				if (ctx->stream.meta_interval && ctx->stream.meta_next == 0) {
./squeezetiny/stream.c:					if (ctx->stream.meta_left == 0) {
./squeezetiny/stream.c:						int n = recv(ctx->fd, &c, 1, 0);
./squeezetiny/stream.c:						ctx->stream.meta_left = 16 * c;
./squeezetiny/stream.c:						ctx->stream.header_len = 0; // amount of received meta data
./squeezetiny/stream.c:					if (ctx->stream.meta_left) {
./squeezetiny/stream.c:						int n = recv(ctx->fd, ctx->stream.header + ctx->stream.header_len, ctx->stream.meta_left, 0);
./squeezetiny/stream.c:						ctx->stream.meta_left -= n;
./squeezetiny/stream.c:						ctx->stream.header_len += n;
./squeezetiny/stream.c:					if (ctx->stream.meta_left == 0) {
./squeezetiny/stream.c:						if (ctx->stream.header_len) {
./squeezetiny/stream.c:							*(ctx->stream.header + ctx->stream.header_len) = '\0';
./squeezetiny/stream.c:							LOG_INFO("[%p] icy meta: len: %u\n%s", ctx, ctx->stream.header_len, ctx->stream.header);
./squeezetiny/stream.c:							ctx->stream.meta_send = true;
./squeezetiny/stream.c:						ctx->stream.meta_next = ctx->stream.meta_interval;
./squeezetiny/stream.c:					space = min(_buf_space(ctx->streambuf), _buf_cont_write(ctx->streambuf));
./squeezetiny/stream.c:					if (ctx->stream.meta_interval) {
./squeezetiny/stream.c:						space = min(space, ctx->stream.meta_next);
./squeezetiny/stream.c:					n = recv(ctx->fd, ctx->streambuf->writep, space, 0);
./squeezetiny/stream.c:						LOG_INFO("[%p] end of stream (t:%lld)", ctx, ctx->stream.bytes);
./squeezetiny/stream.c:						_buf_inc_writep(ctx->streambuf, n);
./squeezetiny/stream.c:						ctx->stream.bytes += n;
./squeezetiny/stream.c:						if (ctx->stream.meta_interval) {
./squeezetiny/stream.c:							ctx->stream.meta_next -= n;
./squeezetiny/stream.c:					if (ctx->stream.state == STREAMING_BUFFERING && ctx->stream.bytes > ctx->stream.threshold) {
./squeezetiny/stream.c:						ctx->stream.state = STREAMING_HTTP;
./squeezetiny/stream.c:	ctx->streambuf = &ctx->__s_buf;
./squeezetiny/stream.c:	buf_init(ctx->streambuf, ((streambuf_size / (BYTES_PER_FRAME * 3)) * BYTES_PER_FRAME * 3));
./squeezetiny/stream.c:	if (ctx->streambuf->buf == NULL) {
./squeezetiny/stream.c:	ctx->stream_running = true;
./squeezetiny/stream.c:	ctx->stream.state = STOPPED;
./squeezetiny/stream.c:	ctx->stream.header = malloc(MAX_HEADER);
./squeezetiny/stream.c:	*ctx->stream.header = '\0';
./squeezetiny/stream.c:	ctx->fd = -1;
./squeezetiny/stream.c:	touch_memory(ctx->streambuf->buf, ctx->streambuf->size);
./squeezetiny/stream.c:	pthread_create(&ctx->stream_thread, &attr, (void *(*)(void*)) stream_thread, ctx);
./squeezetiny/stream.c:	ctx->stream_running = false;
./squeezetiny/stream.c:	pthread_join(ctx->stream_thread, NULL);
./squeezetiny/stream.c:	free(ctx->stream.header);
./squeezetiny/stream.c:	buf_destroy(ctx->streambuf);
./squeezetiny/stream.c:	buf_flush(ctx->streambuf);
./squeezetiny/stream.c:	ctx->stream.header_len = header_len;
./squeezetiny/stream.c:	memcpy(ctx->stream.header, header, header_len);
./squeezetiny/stream.c:	*(ctx->stream.header+header_len) = '\0';
./squeezetiny/stream.c:	LOG_INFO("[%p] opening local file: %s", ctx, ctx->stream.header);
./squeezetiny/stream.c:	ctx->fd = open(ctx->stream.header, O_RDONLY | O_BINARY);
./squeezetiny/stream.c:	ctx->fd = open(ctx->stream.header, O_RDONLY);
./squeezetiny/stream.c:	ctx->stream.state = STREAMING_FILE;
./squeezetiny/stream.c:	if (ctx->fd < 0) {
./squeezetiny/stream.c:		LOG_WARN("[%p] can't open file: %s", ctx, ctx->stream.header);
./squeezetiny/stream.c:		ctx->stream.state = DISCONNECT;
./squeezetiny/stream.c:	ctx->stream.cont_wait = false;
./squeezetiny/stream.c:	ctx->stream.meta_interval = 0;
./squeezetiny/stream.c:	ctx->stream.meta_next = 0;
./squeezetiny/stream.c:	ctx->stream.meta_left = 0;
./squeezetiny/stream.c:	ctx->stream.meta_send = false;
./squeezetiny/stream.c:	ctx->stream.sent_headers = false;
./squeezetiny/stream.c:	ctx->stream.bytes = 0;
./squeezetiny/stream.c:	ctx->stream.threshold = threshold;
./squeezetiny/stream.c:		ctx->stream.state = DISCONNECT;
./squeezetiny/stream.c:		ctx->stream.disconnect = UNREACHABLE;
./squeezetiny/stream.c:	buf_flush(ctx->streambuf);
./squeezetiny/stream.c:	ctx->fd = sock;
./squeezetiny/stream.c:	ctx->stream.state = SEND_HEADERS;
./squeezetiny/stream.c:	ctx->stream.cont_wait = cont_wait;
./squeezetiny/stream.c:	ctx->stream.meta_interval = 0;
./squeezetiny/stream.c:	ctx->stream.meta_next = 0;
./squeezetiny/stream.c:	ctx->stream.meta_left = 0;
./squeezetiny/stream.c:	ctx->stream.meta_send = false;
./squeezetiny/stream.c:	ctx->stream.header_len = header_len;
./squeezetiny/stream.c:	memcpy(ctx->stream.header, header, header_len);
./squeezetiny/stream.c:	*(ctx->stream.header+header_len) = '\0';
./squeezetiny/stream.c:	LOG_INFO("[%p] header: %s", ctx, ctx->stream.header);
./squeezetiny/stream.c:	ctx->stream.sent_headers = false;
./squeezetiny/stream.c:	ctx->stream.bytes = 0;
./squeezetiny/stream.c:	ctx->stream.threshold = threshold;
